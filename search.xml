<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>并发编程（三）</title>
      <link href="article/d7a792d0.html"/>
      <url>article/d7a792d0.html</url>
      
        <content type="html"><![CDATA[<h2 id="三、原子操作CAS"><a href="#三、原子操作CAS" class="headerlink" title="三、原子操作CAS"></a>三、原子操作CAS</h2><h3 id="1、什么是原子操作？如何实现？"><a href="#1、什么是原子操作？如何实现？" class="headerlink" title="1、什么是原子操作？如何实现？"></a>1、什么是原子操作？如何实现？</h3><p>​    假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时， 要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说是原子的。</p><p>​    实现原子操作可以使用锁，锁机制，满足基本的需求是没有问题的，但是有的时候我们的需求并非这么简单。我们需要更有效，更加灵活的机制。</p><a id="more"></a><p>​     synchronized 关键字是基于阻塞的锁机制，也就是说当一个线程拥有锁的时候， 访问同一资源的其它线程需要等待，直到该线程释放锁，</p><p>​    这里会有些问题:首先，如果被阻塞的线程优先级很高很重要怎么办?其次，如果获得锁的线程一直不释放锁怎么办?(这种情况是非常糟糕的)。还有一种情况，如果有大量的线程来竞争资源，那 CPU 将会花费大量的时间和资源来处理这些竞争，同时，还有可能出现一些例如死锁之类的情况，最后，其实锁机制是一种比较粗糙，粒度比较大的机制，相对于像计数器这样的需求有点儿过于笨重。</p><p>​    实现原子操作还可以使用当前的处理器基本都支持 CAS()的指令，只不过每 个厂家所实现的算法并不一样，每一个 CAS 操作过程都包含三个运算符:一个内存地址 V，一个期望的值A和一个新值B，操作的时候如果这个地址上存放的值等于这个期望的值A，则将地址上的值赋为新值B，否则不做任何操作。</p><p>​    CAS 的基本思路就是，如果这个地址上的值和期望的值相等，则给其赋予新值，否则不做任何事儿，但是要返回原值是多少。循环 CAS 就是在一个循环里不 断的做cas操作，直到成功为止。</p><p>​    CAS 是怎么实现线程的安全呢?语言层面不做处理，我们将其交给硬件——CPU和内存，利用CPU的多处理能力，实现硬件层面的阻塞，再加上volatile变量的特性即可实现基于原子操作的线程安全。</p><h3 id="2、CAS实现原子操作的三大问题"><a href="#2、CAS实现原子操作的三大问题" class="headerlink" title="2、CAS实现原子操作的三大问题"></a>2、CAS实现原子操作的三大问题</h3><h4 id="1）ABA问题"><a href="#1）ABA问题" class="headerlink" title="1）ABA问题"></a>1）ABA问题</h4><p>​    因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用 CAS 进行检查时会发现它的值没有发生变化，但是实际上却变化了。</p><p>​    ABA 问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加 1，那么 A→B→A 就会变成 1A→2B→3A。</p><h4 id="2）循环时间长开销大"><a href="#2）循环时间长开销大" class="headerlink" title="2）循环时间长开销大"></a>2）循环时间长开销大</h4><p>​    自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p><h4 id="3）只能保证一个共享变量的原子操作"><a href="#3）只能保证一个共享变量的原子操作" class="headerlink" title="3）只能保证一个共享变量的原子操作"></a>3）只能保证一个共享变量的原子操作</h4><p>​    当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操 作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候 就可以用锁。</p><p>​    还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量 i=2，j=a，合并一下 ij=2a，然后用CAS来操作 ij。从Java 1.5 开始，JDK 提供了AtomicReference类来保证引用对象之间的原子性，就可以把 多个变量放在一个对象里来进行CAS操作。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程（二）</title>
      <link href="article/9ab93182.html"/>
      <url>article/9ab93182.html</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1380874318&auto=0&height=66"></iframe><h2 id="二、线程的并发工具类"><a href="#二、线程的并发工具类" class="headerlink" title="二、线程的并发工具类"></a>二、线程的并发工具类</h2><h3 id="1、Fork-Join"><a href="#1、Fork-Join" class="headerlink" title="1、Fork-Join"></a>1、Fork-Join</h3><p>​    遵循Fork-Join（分治）思想可以让我们写出非常良好的多线程并发程序。在十大计算机经典算法中，使用了分治思想的有快速排序，归并排序，二分查找，同时大数据中M/R也使用了分治思想。</p><p>​    分治法的设计思想是:将一个难以直接解决的大问题，分割成一些规模较小 的相同问题，以便各个击破，分而治之。</p><p>​    分治策略是:对于一个规模为 n 的问题，若该问题可以容易地解决(比如说规模 n 较小)则直接解决，否则将其分解为 k个规模较小的子问题，这些子问题互相独立且与原问题形式相同**(子问题相互之间有联系就会变为动态规范算法)**，递归地解这些子问题，然后将各子问题的解合并得到原问题的解，这种算法设计策略叫做分治法。</p><a id="more"></a><h4 id="1）归并排序"><a href="#1）归并排序" class="headerlink" title="1）归并排序"></a>1）归并排序</h4><p>​    归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列;即先使 每个子序列有序，再使子序列段间有序。</p><p>​    若将两个有序表合并成一个有序表，称为 2-路归并，与之对应的还有多路归 并。</p><p>​    对于给定的一组数据，利用递归与分治技术将数据序列划分成为越来越小的 半子表，在对半子表排序后，再用递归方法将排好序的半子表合并成为越来越大 的有序序列。</p><p>​    为了提升性能，有时我们在半子表的个数小于某个数的情况下，对半子表的排序采用其他排序算法，比如插入排序。</p><h4 id="2）FJ原理"><a href="#2）FJ原理" class="headerlink" title="2）FJ原理"></a>2）FJ原理</h4><p><img src="/article/9ab93182/image-20201124221023112.png" alt="image-20201124221023112"></p><p><img src="/article/9ab93182/image-20201124221035086.png" alt="image-20201124221035086"></p><p>​    即当前线程的Task已经全被执行完毕，则自动取到其他线程的Task池中取出Task继续执行。</p><p>​    ForkJoinPool中维护着多个线程(一般为CPU核数)在不断地执行Task，每个线程除了执行自己职务内的Task之外，还会根据自己工作线程的闲置情况去 获取其他繁忙的工作线程的Task，如此一来就能能够减少线程阻塞或是闲置的时间，提高CPU利用率。</p><h4 id="3）FJ标准范式"><a href="#3）FJ标准范式" class="headerlink" title="3）FJ标准范式"></a>3）FJ标准范式</h4><p>​    我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork和join的操作机制，通常我们不直接继承ForkjoinTask类，只需要直接继承其子类。</p><pre><code>1.RecursiveAction，用于没有返回结果的任务2.RecursiveTask，用于有返回值的任务</code></pre><p>​    task 要通过ForkJoinPool来执行，使用submit或invoke提交，两者的区别是:invoke是同步执行，调用之后需要等待任务完成，才能执行后面的代码,submit是异步执行。</p><p>​    join()和get方法当任务完成的时候返回计算结果。</p><p><img src="/article/9ab93182/image-20201124221434571.png" alt="image-20201124221434571"></p><h3 id="2、CountDownLatch"><a href="#2、CountDownLatch" class="headerlink" title="2、CountDownLatch"></a>2、CountDownLatch</h3><p>​    通称闭锁，能够使得一个线程等待其他线程完成各自的工作后再执行。</p><p>​    CountDownLatch是通过计数器来实现的，初始值为任务的数量。每当完成一个任务后，计数器值减一。当计数器值达到0时，表示所有的线程已经完成了任务，然后在闭锁上等待await()方法的线程将恢复任务的执行。</p><p><img src="/article/9ab93182/image-20201124222415883.png" alt="image-20201124222415883"></p><p>​    可以有多个线程调用await()，计数器初始化数量也不必必须等同于需要等待执行的线程数，而是根据实际场景设置。</p><h3 id="3、CyclicBarrier"><a href="#3、CyclicBarrier" class="headerlink" title="3、CyclicBarrier"></a>3、CyclicBarrier</h3><p>​    CyclicBarrier的字面意思是可循环使用(Cyclic)的屏障(Barrier)。它要做的事情是，让一组线程到达一个屏障(也可以叫同步点)时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。</p><p>​    CyclicBarrier还提供一个更高级的构造函数CyclicBarrier(int parties，Runnable barrierAction)，用于在线程到达屏障时，优先执行 barrierAction，可以用于多线程计算数据，最后合并计算结果的场景。</p><h3 id="4、CountDownLatch和CyclicBarrier辨析"><a href="#4、CountDownLatch和CyclicBarrier辨析" class="headerlink" title="4、CountDownLatch和CyclicBarrier辨析"></a>4、CountDownLatch和CyclicBarrier辨析</h3><pre><code>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以反复使用。CountDownLatch.await一般阻塞工作线程，所有的进行预备工作的线程执行countDown，而 CyclicBarrier通过工作线程调用await从而自行阻塞，直到所有工作线程达到指定屏障，再大家一起往下走。在控制多个线程同时运行上，CountDownLatch 可以不限线程数量，而 CyclicBarrier是固定线程数。同时，CyclicBarrier还可以提供一个barrierAction，合并多线程计算结果。</code></pre><h3 id="5、Semaphore"><a href="#5、Semaphore" class="headerlink" title="5、Semaphore"></a>5、Semaphore</h3><p>​    Semaphore(信号量)是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</p><p>​    Semaphore的构造方法 Semaphore(int permits)接受一个整型的数字， 表示可用的许可证数量。Semaphore的用法也很简单，首先线程使用Semaphore的acquire()方法获取一个许可证，使用完之后调用 release()方法归还许可证。还可以用tryAcquire()方法尝试获取许可证。</p><h3 id="6、Exchanger"><a href="#6、Exchanger" class="headerlink" title="6、Exchanger"></a>6、Exchanger</h3><p>​    Exchanger(交换者)是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。</p><p>​    它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过 exchange()方法交换数据，如果第一个线程先执行 exchange()方法，它会一直等待第二个线程也执行 exchange()方法，当两个线程都 到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</p><h3 id="7、Callable、Future和FutureTask"><a href="#7、Callable、Future和FutureTask" class="headerlink" title="7、Callable、Future和FutureTask"></a>7、Callable、Future和FutureTask</h3><p>​    Runnable是一个接口，在它里面只声明了一个 run()方法，由于run()方法返回值为void类型，所以在执行完任务之后无法返回任何结果。</p><p>​    Callable位于java.util.concurrent包下，它也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做call()，这是一个泛型接口，call()函数返回的类型就是传递进来的V类型。</p><p>​    Future就是对于具体的Runnable或者Callable 任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻 塞直到任务返回结果。</p><p><img src="/article/9ab93182/image-20201127164619275.png" alt="image-20201127164619275"></p><p>​    因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了FutureTask。</p><p>​    FutureTask 类实现了RunnableFuture接口，RunnableFuture继承了Runnable接口和Future接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</p><p>​    因此我们通过一个线程运行Callable，但是Thread不支持构造方法中传递Callable的实例，所以我们需要通过FutureTask把一个Callable包装成 Runnable， 然后再通过这个FutureTask拿到Callable运行后的返回值。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程（一）</title>
      <link href="article/aaafdd5a.html"/>
      <url>article/aaafdd5a.html</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=454231736&auto=0&height=66"></iframe><h2 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a>一、基础概念</h2><h3 id="1、什么是进程与线程"><a href="#1、什么是进程与线程" class="headerlink" title="1、什么是进程与线程"></a>1、什么是进程与线程</h3><p>进程：操作系统进行资源分配的最小单位</p><p>线程：CPU调度的最小单位，无法独立进程而存在</p><h3 id="2、CPU核心数和线程数的关系"><a href="#2、CPU核心数和线程数的关系" class="headerlink" title="2、CPU核心数和线程数的关系"></a>2、CPU核心数和线程数的关系</h3><p>一对一关系，使用Intel超线程技术可以使其变成一比二关系。</p><h3 id="3、CPU时间片轮转机制"><a href="#3、CPU时间片轮转机制" class="headerlink" title="3、CPU时间片轮转机制"></a>3、CPU时间片轮转机制</h3><p>RR调度：把CPU时间切片，分配给不同的进程进行运行。</p><p>缺点：上下文切换需要花费20000CPU时间周期</p><a id="more"></a><h3 id="4、并行与并发"><a href="#4、并行与并发" class="headerlink" title="4、并行与并发"></a>4、并行与并发</h3><p>并行：应用可以同时运行的任务数</p><p>并发：一定时间内可以交替执行的任务数（与时间相关）</p><p>并发的优点：</p><ul><li>充分利用CPU资源</li><li>加快相应用户的时间</li><li>可以使代码模块化，异步化，简单化。</li></ul><h3 id="5、线程的数量限制"><a href="#5、线程的数量限制" class="headerlink" title="5、线程的数量限制"></a>5、线程的数量限制</h3><p>在操作系统中，一个进程所能创建的最大线程数如下：</p><p>Linux：1000    Windows：2000</p><h3 id="6、JAVA程序天生就是多线程的，那么有几种新启线程的方式？"><a href="#6、JAVA程序天生就是多线程的，那么有几种新启线程的方式？" class="headerlink" title="6、JAVA程序天生就是多线程的，那么有几种新启线程的方式？"></a>6、JAVA程序天生就是多线程的，那么有几种新启线程的方式？</h3><p>结论：一共有两种。</p><ul><li>类Thread</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private static class userThread extends Thread&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            super.run();</span><br><span class="line">            &#x2F;&#x2F;to do my work</span><br><span class="line">            System.out.println(&quot;I am extends Thread&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>接口Runnable</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static class userRunnable  implements Runnable&#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void run() &#123;</span><br><span class="line">         &#x2F;&#x2F;to do my work</span><br><span class="line">         System.out.println(&quot;I am implements Runnable&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>启动方式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        userThread userThread &#x3D; new userThread();</span><br><span class="line">        userThread.start();</span><br><span class="line">        userRunnable userRunnable &#x3D; new userRunnable();</span><br><span class="line">        Thread thread &#x3D; new Thread(userRunnable);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>Thread与Runnable的区别</li></ul><p>Thread是java中对线程的抽象。</p><p>Runnable是对任务（业务逻辑）的抽象。</p><h3 id="7、如何让java线程安全的停止？"><a href="#7、如何让java线程安全的停止？" class="headerlink" title="7、如何让java线程安全的停止？"></a>7、如何让java线程安全的停止？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*jdk线程是协作式的，并非抢占式  </span><br><span class="line"></span><br><span class="line">stop()&#x2F;&#x2F;停止：非常野蛮，可能导致线程中资源不能正确释放</span><br><span class="line">interrupt()&#x2F;&#x2F;中断：对线程发起中断，给线程打了中断标示位，线程可以不理会，正确姿势</span><br><span class="line">Thread.interrupted()&#x2F;&#x2F;静态 ，调用中断后会将中断标识位由true改为false</span><br><span class="line">isinterrupted()&#x2F;&#x2F;返回中断状态</span><br></pre></td></tr></table></figure><h3 id="8、java线程认知"><a href="#8、java线程认知" class="headerlink" title="8、java线程认知"></a>8、java线程认知</h3><p><img src="/article/aaafdd5a/image-20201117225548901.png" alt="image-20201117225548901"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;new Thread（）的时候只是new出了一个线程抽象类的实例，并没有和线程挂钩</span><br><span class="line">&#x2F;&#x2F;当Thread.start()的时候，才真正和线程挂钩</span><br><span class="line"></span><br><span class="line">只允许调用一次如果运行两次，会直接抛出异常</span><br></pre></td></tr></table></figure><ul><li>线程常用方法和线程的状态</li></ul><p><strong>深入理解run()，strat()与yield()</strong></p><p>​        run()方法可以被任意线程调用，start()方法是该线程主动调用。</p><p>​        yield()：使当前线程让出 CPU 占有权，但让出的时间是不可设定的。也 不会释放锁资源。</p><ul><li><p>join()方法 </p><p>​    使用join可以使得线程中执行顺序变成串行，保证不同线程之间的顺序执行</p></li><li><p>线程的优先级</p><p>​    Thread.setPriority(int) //1~10,默认5</p></li><li><p>守护线程</p><p>​    在程序中做一些调度的工作，通过Thread.setDeamon(true)设置。</p></li></ul><h3 id="9、线程间共享"><a href="#9、线程间共享" class="headerlink" title="9、线程间共享"></a>9、线程间共享</h3><h4 id="synchronized内置锁"><a href="#synchronized内置锁" class="headerlink" title="synchronized内置锁"></a><strong>synchronized内置锁</strong></h4><p>​    由于Java支持多个线程同事访问一个对象或对象的成员变量，关键字synchronized可以修饰方法或者以同步块的形式来使用。</p><p>​    它主要确保多个线程在同一时刻，只能有一个线程处于方法或者同步块中，保证了线程对变量访问的可见性和排他性，又称为内置锁机制。</p><p>​    本质是<strong>锁住某个对象</strong>，当修饰在类上时，实际上锁住的是该类在虚拟机中仅有的class对象。所以类锁和对象锁可以并行。</p><h4 id="错误的加锁和原因分析"><a href="#错误的加锁和原因分析" class="headerlink" title="错误的加锁和原因分析"></a>错误的加锁和原因分析</h4><p>​    因为通过synchronized锁住的是对象，加锁过程中对象不能发生变化。</p><h4 id="volatile——最轻量的同步机制"><a href="#volatile——最轻量的同步机制" class="headerlink" title="volatile——最轻量的同步机制"></a>volatile——最轻量的同步机制</h4><p>​    只能保证数据的可见性（旧数据修改后，其他线程能够立即访问到），但不能保证数据的原子性，所以不能取代synchronized。</p><p>​    比较适合<strong>一写多读</strong>的线程工作场景。</p><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p>​    为每个线程提供变量的副本，使得每一个线程都在某一个时间访问到的并非同一个对象，实现了<strong>线程的隔离</strong>。</p><p>​    <em>Spring中什么地方用到了ThreadLocal？（事物）</em></p><h5 id="可能引发内存泄漏的分析"><a href="#可能引发内存泄漏的分析" class="headerlink" title="可能引发内存泄漏的分析"></a>可能引发内存泄漏的分析</h5><h6 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h6><p>Object o = new Object();</p><p>​    执行的方法会打包成一个栈帧在栈上运行，new一个对象时在堆中生成实例 。</p><p>​    栈上的o指向堆中的Object对象，这就是引用。</p><h6 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h6><p>SortRefence。在即将发生内存溢出的时候，先做一次垃圾回收。如果空间还是不够，就会将标记了软引用的对象进行回收。</p><h6 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h6><p>只要发生GC，被弱引用所指的堆内对象实例就会被回收。</p><h6 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h6><p>基本无用，发生GC时候仅通知一下</p><hr><p>​    每个Thread维护了一个ThreadLocalMap，ThreadLocal本身不存储值，仅作为一个key来让线程从ThreadLocalMap中获取value，该map是使用ThreadLocal的弱引用作为key。</p><p>​    因此，引用链如下所示：</p><p><img src="/article/aaafdd5a/image-20201123192854144.png" alt="image-20201123192854144"></p><p>​    当把 ThreadLocal 变量置为 null 以后，没有任何强引用指向 ThreadLocal 实例，所以 ThreadLocal 将会被 gc 回收。这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry，就没有办法访问这些 key 为 null 的 Entry 的 value，如果当前 线程再迟迟不结束的话，这些 key 为 null 的 Entry 的 value 就会一直存在一条强 引用链:Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value，而这块 value 永 远不会被访问到了，所以存在着内存泄露。</p><p>​    只有当前 Thread 结束以后，Current Thread 就不会存在栈中，强引用断开， Current Thread、Map value 将全部被 GC 回收。最好的做法是不在需要使用 ThreadLocal 变量后，都调用它的 remove()方法，清除数据。</p><p>​    ThreadLocal 内存泄漏的根源是:由于 ThreadLocalMap 的生命周期跟 Thread 一样长，如果没有手动删除对应 key 就会导致内存泄漏，而不是因为弱引用。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>1、JVM 利用设置 ThreadLocalMap 的 Key为弱引用，来避免内存泄露。</p><p>2、JVM 利用调用 remove、get、set 方法的时候，回收弱引用</p><p>3、当 ThreadLocal 存储很多 Key 为 null 的 Entry 的时候，而不再去调用 remove、get、set 方法，那么将导致内存泄漏。</p><p>4、使用线程池**+** ThreadLocal 时要小心，因为这种情况下，线程是一直在不断的重复运行的，从而也就造成了 value 可能造成累积的情况。</p><h3 id="10、线程间协作"><a href="#10、线程间协作" class="headerlink" title="10、线程间协作"></a>10、线程间协作</h3><p>​    线程之间相互配合，完成某项工作，比如:一个线程修改了一个对象的值， 而另一个线程感知到了变化，然后进行相应的操作，整个过程开始于一个线程， 而最终执行又是另一个线程。前者是生产者，后者就是消费者，这种模式隔离了 “做什么”(what)和“怎么做”(How)，简单的办法是让消费者线程不断地 循环检查变量是否符合预期在 while 循环中设置不满足的条件，如果条件满足则 退出 while 循环，从而完成消费者的工作。却存在如下问题:</p><p> 难以确保及时性。</p><p>2、难以降低开销。如果降低睡眠的时间，比如休眠1毫秒，这样消费者能更加迅速地发现条件变化，但是却可能消耗更多的处理器资源，造成了无端的浪费。</p><h4 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h4><p>标准范式遵循如下原则：</p><hr><p>等待方原则</p><p>1、获取对象的锁</p><p>2、如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。</p><p>3、条件满足则执行对应的逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">synchronized(对象)&#123;</span><br><span class="line">while(条件不满足)&#123;</span><br><span class="line">对象.wait();</span><br><span class="line">&#125;</span><br><span class="line">对应的处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通知方原则</p><p>1、获取对象的锁</p><p>2、改变条件</p><p>3、通知所有等待在对象上的线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized(对象)&#123;</span><br><span class="line">改变条件</span><br><span class="line">对象.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>​    <strong>在调用 wait()、notify()系列方法之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步块中调用 wait()方法、notify()系列方法</strong>。</p><p>​    进入 wait()方法后，<strong>当前线程释放锁</strong>，在从 wait()返回前，线程与其他线程竞争重新获得锁，执行 notify()系列方法的线程退出调用了 notifyAll 的 synchronized 代码块的时候后，他们就会去竞争。如果其中一个线程获得了该对象锁，它就会继续往下执行，在它退出 synchronized 代码块，释放锁后，其他的已经被唤醒的线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。</p><p>​    尽可能用 notifyall()，谨慎使用 notify()，因为 notify()只会唤醒一个线程，我们无法确保被唤醒的这个线程一定就是我们需要唤醒的线程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码分析</title>
      <link href="article/9439442c.html"/>
      <url>article/9439442c.html</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=21253900&auto=0&height=66"></iframe><h1 id="Spring源码分析"><a href="#Spring源码分析" class="headerlink" title="Spring源码分析"></a>Spring源码分析</h1><h2 id="一、源码下载与编译"><a href="#一、源码下载与编译" class="headerlink" title="一、源码下载与编译"></a>一、源码下载与编译</h2><p>​    环境说明：</p><ul><li>Spring-framerwork5.3.2</li><li>Gradle6.7</li><li>IDEA2020.2.3</li></ul><h3 id="Mac下Gradle的安装与配置"><a href="#Mac下Gradle的安装与配置" class="headerlink" title="Mac下Gradle的安装与配置"></a>Mac下Gradle的安装与配置</h3><p>​    进入Gradle官网，选择安装版本，Binary-only下载压缩包。</p><p>​    将在指定目录下解压，然后配置环境变量。</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 进入用户目录下的配置文件</span><br><span class="line">vim ~&#x2F;.bash_profile</span><br><span class="line"># 修改.bash_profile文件, 在文件的最后加上如下配置: </span><br><span class="line"># export GRADLE&#x3D;&#x2F;指定路径&#x2F;gradle-6.7</span><br><span class="line"># export PATH&#x3D;$PATH:$GRADLE&#x2F;bin</span><br><span class="line"># 修改后, 按[Esc], 命令&quot;:wq&quot;保存退出, 并在终端使用如下命令使配置生效:</span><br><span class="line">source ~&#x2F;.bash_profile</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><a id="more"></a><h4 id="bash-profile找不到"><a href="#bash-profile找不到" class="headerlink" title=".bash_profile找不到"></a>.bash_profile找不到</h4><p>​    直接vim ~/.bash_profile进入的是空文件，而且.bash_profile是隐藏文件，没有开启显示的情况下访达不能直接搜索到。</p><p>​    查阅资料都是说如果找不到就自己新建一个，但环境变量如果消失的话，应该是除了cd以外的命令均无法使用。并且我之前配置的java环境变量使用-version命令能够正常显示，说明.bash_profile文件应该还存在并且生效。</p><p>​    最后发现，由于我此时使用的是提权的root用户，～进入的是/var/root路径。新打开一个终端，使用普通用户访问～路径，进入的是/Users/用户名目录。此时能够正常访问到之前设置的.bash_profile文件。</p><h2 id="Spring源码下载"><a href="#Spring源码下载" class="headerlink" title="Spring源码下载"></a>Spring源码下载</h2><p>​    1.在指定位置新建文件夹，终端进入后输入以下语句以进行下载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;gitee.com&#x2F;mirrors&#x2F;Spring-Framework.git</span><br></pre></td></tr></table></figure><p>2.设置阿里云镜像提速</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在下载好的Spring源码文件夹里的build.gradle 加上</span><br><span class="line">allprojects &#123;</span><br><span class="line">repositories &#123;</span><br><span class="line">maven&#123; url &#39;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;&#39;&#125;</span><br><span class="line">maven &#123; url &#39;https:&#x2F;&#x2F;maven.aliyun.com&#x2F;repository&#x2F;gradle-plugin&#39; &#125;</span><br><span class="line">maven &#123; url &#39;https:&#x2F;&#x2F;maven.aliyun.com&#x2F;repository&#x2F;google&#39; &#125;</span><br><span class="line">maven &#123; url &#39;https:&#x2F;&#x2F;maven.aliyun.com&#x2F;repository&#x2F;jcenter&#39;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/article/9439442c/image-20201116002343235.png" alt="image-20201116002343235"></p><p>3.cd进入下载的Spring源码路径执行gradle命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gradle objenesisRepackJar</span><br><span class="line">gradle cglibRepackJar</span><br><span class="line">gradlew :spring-oxm:compileTestJava</span><br></pre></td></tr></table></figure><hr><h3 id="可能出现的问题："><a href="#可能出现的问题：" class="headerlink" title="可能出现的问题："></a>可能出现的问题：</h3><p>1、Could not determine the dependencies of task ‘:spring-oxm:compileTestKotlin’.</p><p><img src="/article/9439442c/image-20201115143844838.png" alt="image-20201115143844838"></p><p>解决方法：</p><p>​    由于我使用的是最新版本Gradle，所以需要下载最新版本Spring源码进行编译，或者对Gradle进行降级。</p><hr><p>2、Could not determine the dependencies of task ‘:spring-core:objenesisRepackJar’.</p><p><img src="/article/9439442c/image-20201115144348247.png" alt="image-20201115144348247"></p><p>解决方法：</p><p>​    运行gradle objenesisRepackJar，然后重新执行gradlew :spring-oxm:compileTestJava</p><hr><p>3、Could not GET ‘xxx’.Read timed out</p><p><img src="/article/9439442c/image-20201115144532777.png" alt="image-20201115144532777"></p><p>解决方法：</p><p>​    网络问题导致超时，重新执行gradlew :spring-oxm:compileTestJava直到编译成功</p><p>4、连续编译失败（网络问题）</p><p><img src="/article/9439442c/image-20201115160644761.png" alt="image-20201115160644761"></p><p>解决方法：</p><p>​    分别单独执行gradlew :spring-oxm:compileJava，gradlew :spring-core:compileTestFixturesKotlin以及gradlew :spring-aop:compileJava。</p><p>​    执行完成后重新执行gradlew :spring-oxm:compileTestJava直到编译成功</p><hr><p>最终结果</p><p><img src="/article/9439442c/image-20201115172915609.png" alt="image-20201115172915609"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    此次源码下载与编译花费了我大量时间，从早上十点到下午五点半才最终编译成功。</p><p>​    最大的问题就是第一个，由于Gradle版本过于新，导致较旧的spring源码无法正常编译。网上直接搜索所报错误，基本上都是安卓相关，没有任何参考价值。</p><p>​    其次就是编译过程中jar包下载，让我感觉回到了15年前拨号上网的时候。不仅下载巨慢，而且期间不断报错，一遍遍重新编译的过程中耗费了我非常多的精力。</p><p>​    尤其是在最后98%阶段的byte-buddy-1.10.15.jar包，只有3.3m的大小，但从下载到最终结束一共花费了两个多小时。因为每次下载到最后总会报出ssl管道异常关闭的错误，不得不一遍遍重复。</p><p><img src="/article/9439442c/image-20201115174014323.png" alt="image-20201115174014323"></p><hr><p>​    现在是晚上12点，idea终于开始正常编译了，以下是经验教训。</p><ul><li><p>​    最新版本的Gradle+最新版本的Spring可以完成编译，但是idea无法正常导入。一开始我以为是编译慢的原因，结果编译了两个小时还没动静，就重新开始查阅资料，一遍一遍的重装。最后发现，还得把<strong>idea的版本升级到最新</strong>，才能正常导入。</p><p>​    此处借鉴<a href="https://blog.csdn.net/qq_38425803/article/details/109670018">夯实Spring（五） | 搭建Spring源码环境</a></p></li><li><p>  Gradle编译前，可以通过设置阿里云镜像提速，不然得像我一样下载几个小时</p></li></ul><p>​    至于有没有效果，因为我已经下载过了，所以不清楚提速有多快。</p><ul><li>通过设置本地Gradle，避免idea从网页重复下载</li></ul><p><img src="/article/9439442c/image-20201116002545689.png" alt="image-20201116002545689"></p><hr><h3 id="截图留念"><a href="#截图留念" class="headerlink" title="截图留念"></a>截图留念<img src="/article/9439442c/image-20201116003207637.png" alt="image-20201116003207637"></h3>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>与其不断的规划，我决定先行动起来</title>
      <link href="article/a4b9cf5f.html"/>
      <url>article/a4b9cf5f.html</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=22842399&auto=0&height=66"></iframe><p><em>这是一篇关于我的故事</em></p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>​    我决定开设个人博客了。工作两年多以来，从我正式入职开始，公司就没有把我当作新人使用。无止境的产品更新需求，开发过程中遇到的各类bug，客户的对接…由于工作任务繁重，初始薪资太低，生存下去成为了我在北京最首要的任务。</p><a id="more"></a><h2 id="第一年"><a href="#第一年" class="headerlink" title="第一年"></a>第一年</h2><p>​    入职第一年，我所有的时间全部花在解决公司项目的问题上面。</p><p>​    经历过连续一个半月的凌晨三点到家，七点爬起来去上班。调试解决过无数奇异bug，总结编写了许多文档。对接了许多客户，尽心尽力为其解决问题。</p><p>​    凭借个人努力，这一年期间我摸透了项目各种需求流程，独自开发了多项功能业务模块。虽然我在项目开发中越来越得心应手，但由于我所在的项目组所用技术较老，个人提升实在有限。</p><p>​    这一年间最大的任务和收获，是由我独自负责对接深信服接口。由我开发的接口项目，无论是对接还是验收都是最快和运行最稳定的。</p><h2 id="第二年"><a href="#第二年" class="headerlink" title="第二年"></a>第二年</h2><p>​    时间进入到第二年，收入接近翻了一倍，虽然起薪很低，但至少不用一餐只敢点十多块的外卖了。    第二年开始，对于交给我的需求与任务，我已经能非常轻松的完成开发。由于疫情原因，团队组织架构调整。我开始担任小组长，初期领导了一个十人小组。我手下的组员，由于大部分都是新人，除了开发任务外，我还注重其能力提升培养。</p><p>​    年初的工作任务实在是非常繁忙，连续三个月不间断上班，每天15个小时以上的工作时长，我一共只休息了两天。这期间由于护网要求，以及深信服被爆出0day漏洞的原因，我们项目需要进行安全性的整体提升。</p><p>​    由于第一年我有项目漏洞处理经验，三个月时间，我组人员在我带领下对项目进行了整体改造。最终达到了安全基线的所有要求，解决了一系列web漏洞相关问题。由我负责的漏洞修补工作，使得我们产品在护网期间没有报出任何问题，这三个月时间，对于web安全相关知识收获颇多。</p><p>​    如果说第一年实在是为工作任务所迫，没有时间进行其他方面的提升。那么第二年后半期，在漏洞处理解决后，向管理岗转化的时候，我开始有了大把时间，却变得稍有懈怠，进入了一个舒适区陷阱。</p><h3 id="惊醒"><a href="#惊醒" class="headerlink" title="惊醒"></a>惊醒</h3><p>​    日子一天天过去，曾经我有计划工作积攒经验三年后跳槽，我向往着阿里，字节，腾讯，微软等大厂。之前也对其招聘标准有一个模糊的概念，那就是我现在的技术不足以去面试，但我所掌握的东西距离所需技术究竟缺少多少呢？我并没有很清楚的认识到。</p><p>​    打开招聘网站，社招除了工作经验的要求外，各种所需技术就是轻飘飘的一句话，但这一句话的背后，所需要掌握的知识绝对是海量的。</p><p>​    某一天看番后闲着没事干，我打开了b站搜索java面试。其中尚硅谷周阳老师的面试指导第一章节就把我骂得头破血流，我这时我才明白，我之前两年的工作经验，对于当前的公司，我是重要的人才。因为我熟练掌握项目需求，开发所需技能。但实际上，我只是一个普通的CRUD工程师而已。为数不多的有价值技能，是我对待工作的认真态度，web漏洞的修复经验，工作期间见到的各类bug而已。</p><h3 id="决意"><a href="#决意" class="headerlink" title="决意"></a>决意</h3><p>​    我决定制定计划，从基础开始覆盖整个java高级工程师所需技术栈，用五至十个月时间，完整掌握所有相关内容。</p><p>​    由于目前有新项目在身，我首先要以公司工作内容为主，每天所有业余时间拿来学习。如果工作内容占用时间不是很多，快速掌握的情况下，也许可以冲击春招（5个月），如果工作内容繁重，那就只能以工作内容为主，冲击明年的秋招。</p><p>​    学习过程中所有资料，将会整理并发布到该个人博客。</p><p>​    </p>]]></content>
      
      
      
        <tags>
            
            <tag> 初めて </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
