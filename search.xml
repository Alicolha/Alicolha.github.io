<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>并发编程（一）</title>
      <link href="article/aaafdd5a.html"/>
      <url>article/aaafdd5a.html</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=454231736&auto=0&height=66"></iframe><h2 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a>一、基础概念</h2><h3 id="1、什么是进程与线程"><a href="#1、什么是进程与线程" class="headerlink" title="1、什么是进程与线程"></a>1、什么是进程与线程</h3><p>进程：操作系统进行资源分配的最小单位</p><p>线程：CPU调度的最小单位，无法独立进程而存在</p><h3 id="2、CPU核心数和线程数的关系"><a href="#2、CPU核心数和线程数的关系" class="headerlink" title="2、CPU核心数和线程数的关系"></a>2、CPU核心数和线程数的关系</h3><p>一对一关系，使用Intel超线程技术可以使其变成一比二关系。</p><h3 id="3、CPU时间片轮转机制"><a href="#3、CPU时间片轮转机制" class="headerlink" title="3、CPU时间片轮转机制"></a>3、CPU时间片轮转机制</h3><p>RR调度：把CPU时间切片，分配给不同的进程进行运行。</p><p>缺点：上下文切换需要花费20000CPU时间周期</p><a id="more"></a><h3 id="4、并行与并发"><a href="#4、并行与并发" class="headerlink" title="4、并行与并发"></a>4、并行与并发</h3><p>并行：应用可以同时运行的任务数</p><p>并发：一定时间内可以交替执行的任务数（与时间相关）</p><p>并发的优点：</p><ul><li>充分利用CPU资源</li><li>加快相应用户的时间</li><li>可以使代码模块化，异步化，简单化。</li></ul><h3 id="5、线程的数量限制"><a href="#5、线程的数量限制" class="headerlink" title="5、线程的数量限制"></a>5、线程的数量限制</h3><p>在操作系统中，一个进程所能创建的最大线程数如下：</p><p>Linux：1000    Windows：2000</p><h3 id="6、JAVA程序天生就是多线程的，那么有几种新启线程的方式？"><a href="#6、JAVA程序天生就是多线程的，那么有几种新启线程的方式？" class="headerlink" title="6、JAVA程序天生就是多线程的，那么有几种新启线程的方式？"></a>6、JAVA程序天生就是多线程的，那么有几种新启线程的方式？</h3><p>结论：一共有两种。</p><ul><li>类Thread</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private static class userThread extends Thread&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            super.run();</span><br><span class="line">            &#x2F;&#x2F;to do my work</span><br><span class="line">            System.out.println(&quot;I am extends Thread&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>接口Runnable</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static class userRunnable  implements Runnable&#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void run() &#123;</span><br><span class="line">         &#x2F;&#x2F;to do my work</span><br><span class="line">         System.out.println(&quot;I am implements Runnable&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>启动方式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        userThread userThread &#x3D; new userThread();</span><br><span class="line">        userThread.start();</span><br><span class="line">        userRunnable userRunnable &#x3D; new userRunnable();</span><br><span class="line">        Thread thread &#x3D; new Thread(userRunnable);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>Thread与Runnable的区别</li></ul><p>Thread是java中对线程的抽象。</p><p>Runnable是对任务（业务逻辑）的抽象。</p><h3 id="7、如何让java线程安全的停止？"><a href="#7、如何让java线程安全的停止？" class="headerlink" title="7、如何让java线程安全的停止？"></a>7、如何让java线程安全的停止？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*jdk线程是协作式的，并非抢占式  </span><br><span class="line"></span><br><span class="line">stop()&#x2F;&#x2F;停止：非常野蛮，可能导致线程中资源不能正确释放</span><br><span class="line">interrupt()&#x2F;&#x2F;中断：对线程发起中断，给线程打了中断标示位，线程可以不理会，正确姿势</span><br><span class="line">Thread.interrupted()&#x2F;&#x2F;静态 ，调用中断后会将中断标识位由true改为false</span><br><span class="line">isinterrupted()&#x2F;&#x2F;返回中断状态</span><br></pre></td></tr></table></figure><h3 id="8、java线程认知"><a href="#8、java线程认知" class="headerlink" title="8、java线程认知"></a>8、java线程认知</h3><p><img src="/article/aaafdd5a/image-20201117225548901.png" alt="image-20201117225548901"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;new Thread（）的时候只是new出了一个线程抽象类的实例，并没有和线程挂钩</span><br><span class="line">&#x2F;&#x2F;当Thread.start()的时候，才真正和线程挂钩</span><br><span class="line"></span><br><span class="line">只允许调用一次如果运行两次，会直接抛出异常</span><br></pre></td></tr></table></figure><ul><li>线程常用方法和线程的状态</li></ul><p><strong>深入理解run()，strat()与yield()</strong></p><p>​        run()方法可以被任意线程调用，start()方法是该线程主动调用。</p><p>​        yield()：使当前线程让出 CPU 占有权，但让出的时间是不可设定的。也 不会释放锁资源。</p><ul><li><p>join()方法 </p><p>​    使用join可以使得线程中执行顺序变成串行，保证不同线程之间的顺序执行</p></li><li><p>线程的优先级</p><p>​    Thread.setPriority(int) //1~10,默认5</p></li><li><p>守护线程</p><p>​    在程序中做一些调度的工作，通过Thread.setDeamon(true)设置。</p></li></ul><h3 id="9、线程间共享"><a href="#9、线程间共享" class="headerlink" title="9、线程间共享"></a>9、线程间共享</h3><h4 id="synchronized内置锁"><a href="#synchronized内置锁" class="headerlink" title="synchronized内置锁"></a><strong>synchronized内置锁</strong></h4><p>​    由于Java支持多个线程同事访问一个对象或对象的成员变量，关键字synchronized可以修饰方法或者以同步块的形式来使用。</p><p>​    它主要确保多个线程在同一时刻，只能有一个线程处于方法或者同步块中，保证了线程对变量访问的可见性和排他性，又称为内置锁机制。</p><p>​    本质是<strong>锁住某个对象</strong>，当修饰在类上时，实际上锁住的是该类在虚拟机中仅有的class对象。所以类锁和对象锁可以并行。</p><h4 id="错误的加锁和原因分析"><a href="#错误的加锁和原因分析" class="headerlink" title="错误的加锁和原因分析"></a>错误的加锁和原因分析</h4><p>​    因为通过synchronized锁住的是对象，加锁过程中对象不能发生变化。</p><h4 id="volatile——最轻量的同步机制"><a href="#volatile——最轻量的同步机制" class="headerlink" title="volatile——最轻量的同步机制"></a>volatile——最轻量的同步机制</h4><p>​    只能保证数据的可见性（旧数据修改后，其他线程能够立即访问到），但不能保证数据的原子性，所以不能取代synchronized。</p><p>​    比较适合<strong>一写多读</strong>的线程工作场景。</p><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p>​    为每个线程提供变量的副本，使得每一个线程都在某一个时间访问到的并非同一个对象，实现了<strong>线程的隔离</strong>。</p><p>​    <em>Spring中什么地方用到了ThreadLocal？（事物）</em></p><h5 id="可能引发内存泄漏的分析"><a href="#可能引发内存泄漏的分析" class="headerlink" title="可能引发内存泄漏的分析"></a>可能引发内存泄漏的分析</h5><h6 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h6><p>Object o = new Object();</p><p>​    执行的方法会打包成一个栈帧在栈上运行，new一个对象时在堆中生成实例 。</p><p>​    栈上的o指向堆中的Object对象，这就是引用。</p><h6 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h6><p>SortRefence。在即将发生内存溢出的时候，先做一次垃圾回收。如果空间还是不够，就会将标记了软引用的对象进行回收。</p><h6 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h6><p>只要发生GC，被弱引用所指的堆内对象实例就会被回收。</p><h6 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h6><p>基本无用，发生GC时候仅通知一下</p><hr><p>​    每个Thread维护了一个ThreadLocalMap，ThreadLocal本身不存储值，仅作为一个key来让线程从ThreadLocalMap中获取value，该map是使用ThreadLocal的弱引用作为key。</p><p>​    因此，引用链如下所示：</p><p><img src="/article/aaafdd5a/image-20201123192854144.png" alt="image-20201123192854144"></p><p>​    当把 ThreadLocal 变量置为 null 以后，没有任何强引用指向 ThreadLocal 实例，所以 ThreadLocal 将会被 gc 回收。这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry，就没有办法访问这些 key 为 null 的 Entry 的 value，如果当前 线程再迟迟不结束的话，这些 key 为 null 的 Entry 的 value 就会一直存在一条强 引用链:Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value，而这块 value 永 远不会被访问到了，所以存在着内存泄露。</p><p>​    只有当前 Thread 结束以后，Current Thread 就不会存在栈中，强引用断开， Current Thread、Map value 将全部被 GC 回收。最好的做法是不在需要使用 ThreadLocal 变量后，都调用它的 remove()方法，清除数据。</p><p>​    ThreadLocal 内存泄漏的根源是:由于 ThreadLocalMap 的生命周期跟 Thread 一样长，如果没有手动删除对应 key 就会导致内存泄漏，而不是因为弱引用。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>1、JVM 利用设置 ThreadLocalMap 的 Key为弱引用，来避免内存泄露。</p><p>2、JVM 利用调用 remove、get、set 方法的时候，回收弱引用</p><p>3、当 ThreadLocal 存储很多 Key 为 null 的 Entry 的时候，而不再去调用 remove、get、set 方法，那么将导致内存泄漏。</p><p>4、使用线程池**+** ThreadLocal 时要小心，因为这种情况下，线程是一直在不断的重复运行的，从而也就造成了 value 可能造成累积的情况。</p><h3 id="10、线程间协作"><a href="#10、线程间协作" class="headerlink" title="10、线程间协作"></a>10、线程间协作</h3><p>​    线程之间相互配合，完成某项工作，比如:一个线程修改了一个对象的值， 而另一个线程感知到了变化，然后进行相应的操作，整个过程开始于一个线程， 而最终执行又是另一个线程。前者是生产者，后者就是消费者，这种模式隔离了 “做什么”(what)和“怎么做”(How)，简单的办法是让消费者线程不断地 循环检查变量是否符合预期在 while 循环中设置不满足的条件，如果条件满足则 退出 while 循环，从而完成消费者的工作。却存在如下问题:</p><p> 难以确保及时性。</p><p>2、难以降低开销。如果降低睡眠的时间，比如休眠1毫秒，这样消费者能更加迅速地发现条件变化，但是却可能消耗更多的处理器资源，造成了无端的浪费。</p><h4 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h4><p>标准范式遵循如下原则：</p><hr><p>等待方原则</p><p>1、获取对象的锁</p><p>2、如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。</p><p>3、条件满足则执行对应的逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">synchronized(对象)&#123;</span><br><span class="line">while(条件不满足)&#123;</span><br><span class="line">对象.wait();</span><br><span class="line">&#125;</span><br><span class="line">对应的处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通知方原则</p><p>1、获取对象的锁</p><p>2、改变条件</p><p>3、通知所有等待在对象上的线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized(对象)&#123;</span><br><span class="line">改变条件</span><br><span class="line">对象.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>​    <strong>在调用 wait()、notify()系列方法之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步块中调用 wait()方法、notify()系列方法</strong>。</p><p>​    进入 wait()方法后，<strong>当前线程释放锁</strong>，在从 wait()返回前，线程与其他线程竞争重新获得锁，执行 notify()系列方法的线程退出调用了 notifyAll 的 synchronized 代码块的时候后，他们就会去竞争。如果其中一个线程获得了该对象锁，它就会继续往下执行，在它退出 synchronized 代码块，释放锁后，其他的已经被唤醒的线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。</p><p>​    尽可能用 notifyall()，谨慎使用 notify()，因为 notify()只会唤醒一个线程，我们无法确保被唤醒的这个线程一定就是我们需要唤醒的线程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码分析</title>
      <link href="article/9439442c.html"/>
      <url>article/9439442c.html</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=21253900&auto=0&height=66"></iframe><h1 id="Spring源码分析"><a href="#Spring源码分析" class="headerlink" title="Spring源码分析"></a>Spring源码分析</h1><h2 id="一、源码下载与编译"><a href="#一、源码下载与编译" class="headerlink" title="一、源码下载与编译"></a>一、源码下载与编译</h2><p>​    环境说明：</p><ul><li>Spring-framerwork5.3.2</li><li>Gradle6.7</li><li>IDEA2020.2.3</li></ul><h3 id="Mac下Gradle的安装与配置"><a href="#Mac下Gradle的安装与配置" class="headerlink" title="Mac下Gradle的安装与配置"></a>Mac下Gradle的安装与配置</h3><p>​    进入Gradle官网，选择安装版本，Binary-only下载压缩包。</p><p>​    将在指定目录下解压，然后配置环境变量。</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 进入用户目录下的配置文件</span><br><span class="line">vim ~&#x2F;.bash_profile</span><br><span class="line"># 修改.bash_profile文件, 在文件的最后加上如下配置: </span><br><span class="line"># export GRADLE&#x3D;&#x2F;指定路径&#x2F;gradle-6.7</span><br><span class="line"># export PATH&#x3D;$PATH:$GRADLE&#x2F;bin</span><br><span class="line"># 修改后, 按[Esc], 命令&quot;:wq&quot;保存退出, 并在终端使用如下命令使配置生效:</span><br><span class="line">source ~&#x2F;.bash_profile</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><a id="more"></a><h4 id="bash-profile找不到"><a href="#bash-profile找不到" class="headerlink" title=".bash_profile找不到"></a>.bash_profile找不到</h4><p>​    直接vim ~/.bash_profile进入的是空文件，而且.bash_profile是隐藏文件，没有开启显示的情况下访达不能直接搜索到。</p><p>​    查阅资料都是说如果找不到就自己新建一个，但环境变量如果消失的话，应该是除了cd以外的命令均无法使用。并且我之前配置的java环境变量使用-version命令能够正常显示，说明.bash_profile文件应该还存在并且生效。</p><p>​    最后发现，由于我此时使用的是提权的root用户，～进入的是/var/root路径。新打开一个终端，使用普通用户访问～路径，进入的是/Users/用户名目录。此时能够正常访问到之前设置的.bash_profile文件。</p><h2 id="Spring源码下载"><a href="#Spring源码下载" class="headerlink" title="Spring源码下载"></a>Spring源码下载</h2><p>​    1.在指定位置新建文件夹，终端进入后输入以下语句以进行下载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;gitee.com&#x2F;mirrors&#x2F;Spring-Framework.git</span><br></pre></td></tr></table></figure><p>2.设置阿里云镜像提速</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在下载好的Spring源码文件夹里的build.gradle 加上</span><br><span class="line">allprojects &#123;</span><br><span class="line">repositories &#123;</span><br><span class="line">maven&#123; url &#39;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;&#39;&#125;</span><br><span class="line">maven &#123; url &#39;https:&#x2F;&#x2F;maven.aliyun.com&#x2F;repository&#x2F;gradle-plugin&#39; &#125;</span><br><span class="line">maven &#123; url &#39;https:&#x2F;&#x2F;maven.aliyun.com&#x2F;repository&#x2F;google&#39; &#125;</span><br><span class="line">maven &#123; url &#39;https:&#x2F;&#x2F;maven.aliyun.com&#x2F;repository&#x2F;jcenter&#39;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/article/9439442c/image-20201116002343235.png" alt="image-20201116002343235"></p><p>3.cd进入下载的Spring源码路径执行gradle命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gradle objenesisRepackJar</span><br><span class="line">gradle cglibRepackJar</span><br><span class="line">gradlew :spring-oxm:compileTestJava</span><br></pre></td></tr></table></figure><hr><h3 id="可能出现的问题："><a href="#可能出现的问题：" class="headerlink" title="可能出现的问题："></a>可能出现的问题：</h3><p>1、Could not determine the dependencies of task ‘:spring-oxm:compileTestKotlin’.</p><p><img src="/article/9439442c/image-20201115143844838.png" alt="image-20201115143844838"></p><p>解决方法：</p><p>​    由于我使用的是最新版本Gradle，所以需要下载最新版本Spring源码进行编译，或者对Gradle进行降级。</p><hr><p>2、Could not determine the dependencies of task ‘:spring-core:objenesisRepackJar’.</p><p><img src="/article/9439442c/image-20201115144348247.png" alt="image-20201115144348247"></p><p>解决方法：</p><p>​    运行gradle objenesisRepackJar，然后重新执行gradlew :spring-oxm:compileTestJava</p><hr><p>3、Could not GET ‘xxx’.Read timed out</p><p><img src="/article/9439442c/image-20201115144532777.png" alt="image-20201115144532777"></p><p>解决方法：</p><p>​    网络问题导致超时，重新执行gradlew :spring-oxm:compileTestJava直到编译成功</p><p>4、连续编译失败（网络问题）</p><p><img src="/article/9439442c/image-20201115160644761.png" alt="image-20201115160644761"></p><p>解决方法：</p><p>​    分别单独执行gradlew :spring-oxm:compileJava，gradlew :spring-core:compileTestFixturesKotlin以及gradlew :spring-aop:compileJava。</p><p>​    执行完成后重新执行gradlew :spring-oxm:compileTestJava直到编译成功</p><hr><p>最终结果</p><p><img src="/article/9439442c/image-20201115172915609.png" alt="image-20201115172915609"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    此次源码下载与编译花费了我大量时间，从早上十点到下午五点半才最终编译成功。</p><p>​    最大的问题就是第一个，由于Gradle版本过于新，导致较旧的spring源码无法正常编译。网上直接搜索所报错误，基本上都是安卓相关，没有任何参考价值。</p><p>​    其次就是编译过程中jar包下载，让我感觉回到了15年前拨号上网的时候。不仅下载巨慢，而且期间不断报错，一遍遍重新编译的过程中耗费了我非常多的精力。</p><p>​    尤其是在最后98%阶段的byte-buddy-1.10.15.jar包，只有3.3m的大小，但从下载到最终结束一共花费了两个多小时。因为每次下载到最后总会报出ssl管道异常关闭的错误，不得不一遍遍重复。</p><p><img src="/article/9439442c/image-20201115174014323.png" alt="image-20201115174014323"></p><hr><p>​    现在是晚上12点，idea终于开始正常编译了，以下是经验教训。</p><ul><li><p>​    最新版本的Gradle+最新版本的Spring可以完成编译，但是idea无法正常导入。一开始我以为是编译慢的原因，结果编译了两个小时还没动静，就重新开始查阅资料，一遍一遍的重装。最后发现，还得把<strong>idea的版本升级到最新</strong>，才能正常导入。</p><p>​    此处借鉴<a href="https://blog.csdn.net/qq_38425803/article/details/109670018">夯实Spring（五） | 搭建Spring源码环境</a></p></li><li><p>  Gradle编译前，可以通过设置阿里云镜像提速，不然得像我一样下载几个小时</p></li></ul><p>​    至于有没有效果，因为我已经下载过了，所以不清楚提速有多快。</p><ul><li>通过设置本地Gradle，避免idea从网页重复下载</li></ul><p><img src="/article/9439442c/image-20201116002545689.png" alt="image-20201116002545689"></p><hr><h3 id="截图留念"><a href="#截图留念" class="headerlink" title="截图留念"></a>截图留念<img src="/article/9439442c/image-20201116003207637.png" alt="image-20201116003207637"></h3>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>与其不断的规划，我决定先行动起来</title>
      <link href="article/a4b9cf5f.html"/>
      <url>article/a4b9cf5f.html</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=22842399&auto=0&height=66"></iframe><p><em>这是一篇关于我的故事</em></p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>​    我决定开设个人博客了。工作两年多以来，从我正式入职开始，公司就没有把我当作新人使用。无止境的产品更新需求，开发过程中遇到的各类bug，客户的对接…由于工作任务繁重，初始薪资太低，生存下去成为了我在北京最首要的任务。</p><a id="more"></a><h2 id="第一年"><a href="#第一年" class="headerlink" title="第一年"></a>第一年</h2><p>​    入职第一年，我所有的时间全部花在解决公司项目的问题上面。</p><p>​    经历过连续一个半月的凌晨三点到家，七点爬起来去上班。调试解决过无数奇异bug，总结编写了许多文档。对接了许多客户，尽心尽力为其解决问题。</p><p>​    凭借个人努力，这一年期间我摸透了项目各种需求流程，独自开发了多项功能业务模块。虽然我在项目开发中越来越得心应手，但由于我所在的项目组所用技术较老，个人提升实在有限。</p><p>​    这一年间最大的任务和收获，是由我独自负责对接深信服接口。由我开发的接口项目，无论是对接还是验收都是最快和运行最稳定的。</p><h2 id="第二年"><a href="#第二年" class="headerlink" title="第二年"></a>第二年</h2><p>​    时间进入到第二年，收入接近翻了一倍，虽然起薪很低，但至少不用一餐只敢点十多块的外卖了。    第二年开始，对于交给我的需求与任务，我已经能非常轻松的完成开发。由于疫情原因，团队组织架构调整。我开始担任小组长，初期领导了一个十人小组。我手下的组员，由于大部分都是新人，除了开发任务外，我还注重其能力提升培养。</p><p>​    年初的工作任务实在是非常繁忙，连续三个月不间断上班，每天15个小时以上的工作时长，我一共只休息了两天。这期间由于护网要求，以及深信服被爆出0day漏洞的原因，我们项目需要进行安全性的整体提升。</p><p>​    由于第一年我有项目漏洞处理经验，三个月时间，我组人员在我带领下对项目进行了整体改造。最终达到了安全基线的所有要求，解决了一系列web漏洞相关问题。由我负责的漏洞修补工作，使得我们产品在护网期间没有报出任何问题，这三个月时间，对于web安全相关知识收获颇多。</p><p>​    如果说第一年实在是为工作任务所迫，没有时间进行其他方面的提升。那么第二年后半期，在漏洞处理解决后，向管理岗转化的时候，我开始有了大把时间，却变得稍有懈怠，进入了一个舒适区陷阱。</p><h3 id="惊醒"><a href="#惊醒" class="headerlink" title="惊醒"></a>惊醒</h3><p>​    日子一天天过去，曾经我有计划工作积攒经验三年后跳槽，我向往着阿里，字节，腾讯，微软等大厂。之前也对其招聘标准有一个模糊的概念，那就是我现在的技术不足以去面试，但我所掌握的东西距离所需技术究竟缺少多少呢？我并没有很清楚的认识到。</p><p>​    打开招聘网站，社招除了工作经验的要求外，各种所需技术就是轻飘飘的一句话，但这一句话的背后，所需要掌握的知识绝对是海量的。</p><p>​    某一天看番后闲着没事干，我打开了b站搜索java面试。其中尚硅谷周阳老师的面试指导第一章节就把我骂得头破血流，我这时我才明白，我之前两年的工作经验，对于当前的公司，我是重要的人才。因为我熟练掌握项目需求，开发所需技能。但实际上，我只是一个普通的CRUD工程师而已。为数不多的有价值技能，是我对待工作的认真态度，web漏洞的修复经验，工作期间见到的各类bug而已。</p><h3 id="决意"><a href="#决意" class="headerlink" title="决意"></a>决意</h3><p>​    我决定制定计划，从基础开始覆盖整个java高级工程师所需技术栈，用五至十个月时间，完整掌握所有相关内容。</p><p>​    由于目前有新项目在身，我首先要以公司工作内容为主，每天所有业余时间拿来学习。如果工作内容占用时间不是很多，快速掌握的情况下，也许可以冲击春招（5个月），如果工作内容繁重，那就只能以工作内容为主，冲击明年的秋招。</p><p>​    学习过程中所有资料，将会整理并发布到该个人博客。</p><p>​    </p>]]></content>
      
      
      
        <tags>
            
            <tag> 初めて </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
