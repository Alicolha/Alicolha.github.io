<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>并发编程（四）</title>
      <link href="article/608a8bb5.html"/>
      <url>article/608a8bb5.html</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=744722&auto=0&height=66"></iframe><h2 id="四、显式锁和AQS"><a href="#四、显式锁和AQS" class="headerlink" title="四、显式锁和AQS"></a>四、显式锁和AQS</h2><h3 id="1、显式锁"><a href="#1、显式锁" class="headerlink" title="1、显式锁"></a>1、显式锁</h3><p>​    sychronized是作为java语言特性的隐式锁，由于不会在堆中生成对象，锁的获取与释放均为自动，通常情况下消耗小于显式锁Lock。但需求定制自由度上则是Lock更佳。</p><p>​    对于Lock，标准用法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  count++;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  lock.unlock();<span class="comment">//保证获取锁之后，最终能够得到释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2、可重入锁"><a href="#2、可重入锁" class="headerlink" title="2、可重入锁"></a>2、可重入锁</h3><p>​    简单地讲就是:“同一个线程对于已经获得到的锁，可以多次继续申请到该锁的使用权”。而synchronized关键字隐式的支持重进入，比如一个synchronized 修饰的递归方法，在方法执行时，执行线程在获取了锁之后仍能连续多次地获得该锁。ReentrantLock在调用lock()方法时，已经获取到锁的线程，能够再次调用lock()方法获取锁而不被阻塞。</p><h3 id="3、公平锁与非公平锁"><a href="#3、公平锁与非公平锁" class="headerlink" title="3、公平锁与非公平锁"></a>3、公平锁与非公平锁</h3><p>​    在时间上来说先对锁进行获取的请求一定先被满足，那么这个锁是公平的。 反之，是不公平的锁。ReentrantLock提供了一个构造函数，能够控制锁是否是公平的。事实上，公平的锁机制往往没有非公平的效率高。</p><p>​    这是由于线程在激烈竞争的情况下，在恢复一个被挂起的线程与该线程真正开始运行之间存在着严重的延迟。</p><p>​    假设线程A持有一个锁,并且线程B请求这个锁。由于这个锁已被线程A持有,因此B将被挂起。当A释放锁时，B将被唤醒，因此会再次尝试获取锁。与此同时,如果C也请求这个锁，那么C很可能会在B被完全唤醒之前获得、使用以及释放这个锁。</p><p>​    这样的情况是一种“双赢”的局面。B获得锁的时刻并没有推迟，C更早地获得了锁，并且吞吐量也获得了提高。</p><h3 id="4、读写锁"><a href="#4、读写锁" class="headerlink" title="4、读写锁"></a>4、读写锁</h3><p>之前提到锁(如Mutex和ReentrantLock)基本都是排他锁，这些锁在同一时刻只允许一个线程进行访问。</p><p>​    而读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。</p><h3 id="5、Condition接口"><a href="#5、Condition接口" class="headerlink" title="5、Condition接口"></a>5、Condition接口</h3><p>​    任意一个Java对象，都拥有一组监视器方法(定义在 java.lang.Object上)， 主要包括 wait()、wait(long timeout)、notify()以及 notifyAll()方法，这些方法与synchronized同步关键字配合，可以实现等待/通知模式。Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition condition = lock.newCondition();</span><br><span class="line"><span class="comment">//Condition标准范式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionWait</span><span class="params">()</span> <span class="keyword">throws</span> InterrupteException</span>&#123;</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    condition.await();</span><br><span class="line">  &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionSignal</span><span class="params">()</span> <span class="keyword">throws</span> InterrupteException</span>&#123;</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    condition.signal();</span><br><span class="line">  &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、LockSupport"><a href="#6、LockSupport" class="headerlink" title="6、LockSupport"></a>6、LockSupport</h3><p>​    LockSupport定义了一组的公共静态方法，这些方法提供了最基本的线程阻塞和唤醒功能，而LockSupport也成为构建同步组件的基础工具。</p><p>​    LockSupport定义了一组以park开头的方法用来阻塞当前线程，以及unpark(Thread thread)方法来唤醒一个被阻塞的线程。</p><p>​    LockSupport 增加了park(Object blocker)、parkNanos(Object blocker,long nanos)和 parkUntil(Object blocker,long deadline)3 个方法，用于实现阻塞当前线程的功能，其中参数blocker是用来标识当前线程在等待的对象(以下称为阻塞对象)，该对象主要用于问题排查和系统监控。</p><h3 id="7、CLH队列锁"><a href="#7、CLH队列锁" class="headerlink" title="7、CLH队列锁"></a>7、CLH队列锁</h3><p>​    CLH队列锁是一种<strong>基于链表的可扩展、高性能、公平的自旋锁</strong>，申请线程仅仅在本地变量上自旋，它不断轮询前驱的状态，假设发现前驱释放了锁就结束自旋。</p><p>​    当一个线程需要获得锁的时候。</p><p>​    1、创建一个QNode，将其中的locked设置为true表示需要获取锁，myPred表示对其前驱节点的引用。</p><p><img src="/article/608a8bb5/image-20201203143927615.png" alt="image-20201203143927615"></p><p>​    2、线程A<strong>对tail调用getAndSet</strong>方法，使得自己成为队列的尾部，同时获取一个指向其前驱节点的引用myPred</p><p><img src="/article/608a8bb5/image-20201203144121610.png" alt="image-20201203144121610"></p><p>当线程B需要获取锁的时候，同样的流程再来一遍。</p><p><img src="/article/608a8bb5/image-20201203144202523.png" alt="image-20201203144202523"></p><p>​    3、线程就在前驱节点的locked字段上自旋，知道前驱节点释放锁（locked==false）</p><p>​    4、当一个线程需要释放锁的时候，将当前节点的locked设置为false，同时回收前驱节点。</p><p><img src="/article/608a8bb5/image-20201203144343670.png" alt="image-20201203144343670"></p><p>​    如上所示，前驱节点释放锁，线程A的myPred所指向前驱节点的locked字段变为false，线程A就可以获得锁。</p><p>​    CLH队列锁的优点是空间复杂度低，Java中AQS是CLH队列锁的一种变体实现。</p><h3 id="8、AQS"><a href="#8、AQS" class="headerlink" title="8、AQS"></a>8、AQS</h3><p>​    队列同步器AbstractQueuedSynchronizer(以下简称同步器或AQS)，是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。并发包的大师(Doug Lea)期望它能够成为实现大部分同步需求的基础。</p><h4 id="1）使用方式与设计模式"><a href="#1）使用方式与设计模式" class="headerlink" title="1）使用方式与设计模式"></a>1）使用方式与设计模式</h4><p>​    AQS主要使用方式是继承，子类通过继承AQS并且实现他的抽象方法来管理同步状态，在AQS中由一个int型的state来代表这个状态。</p><p>​    在抽象方法的实现过程中免不了要对这个同步状态进行更改，这时就需要使用同步器提供的三个方法（getState()、setState(int newState)和 compareAndSetState(int expect,int update)）来进行操作，来保证状态的改变是安全的。</p><p>​    在实现上，子类推荐被定义为自定义同步组件的静态内部类，AQS自身没有实现任何同步接口，它仅仅是<strong>定义了若干同步状态获取和释放的方法</strong>来供自定义同步组件使用。</p><p>​    同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件(ReentrantLock、 ReentrantReadWriteLock 和 CountDownLatch 等)。</p><p>​    同步器是实现锁(也可以是任意同步组件)的关键，在锁的实现中聚合同步器。可以这样理解二者之间的关系:</p><p>​    锁是面向使用者的，它定义了使用者与锁交互的接口(比如可以允许两个线程并行访问)，隐藏了实现细节;</p><p>​    同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、 线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者所需关注的领域。</p><p>​    实现者需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。</p><p>​    同步器的设计基于<strong>模板方法模式</strong>。模板方法模式的意图是，定义一个操作中的算法的骨架，而将一些步骤的实现延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。我们最常见的就是 Spring 框架里的各种 Template。</p><h4 id="2）AQS中的数据结构-节点与同步队列"><a href="#2）AQS中的数据结构-节点与同步队列" class="headerlink" title="2）AQS中的数据结构-节点与同步队列"></a>2）AQS中的数据结构-节点与同步队列</h4><h5 id="节点Node"><a href="#节点Node" class="headerlink" title="节点Node"></a>节点Node</h5><p>​    由于AQS是CLH队列锁的一种变体实现，毫无疑问，作为队列来说，必然要有一个节点的数据结构来保存我们前面所说的各种域。类似前驱节点，节点的状态等，这个数据结构就是AQS中的内部类Node。作为这个数据结构我们应该关心什么信息？</p><ul><li>线程信息（肯定需要知道我是什么线程</li><li>队列中线程状态（既然知道是哪一个线程，那就需要知道当前线程处于什么样的一个状态。</li><li>前驱和后继线程</li></ul><p>于是Node类设计结构如下</p><p><img src="/article/608a8bb5/image-20201203202209457.png" alt="image-20201203202209457"></p><p>其中包括了:</p><p><strong>线程的 2 种等待模式:</strong></p><p>SHARED:表示线程以共享的模式等待锁(如 ReadLock) </p><p>EXCLUSIVE:表示线程以互斥的模式等待锁(如 ReetrantLock)，互斥就是一把锁只能由一个线程持有，不能同时存在多个线程使用同一个锁</p><p><strong>线程在队列中的状态枚举:</strong></p><p>CANCELLED:值为 1，表示线程的获锁请求已经“取消”</p><p>SIGNAL:值为-1，表示该线程一切都准备好了,就等待锁空闲出来给我</p><p>CONDITION:值为-2，表示线程等待某一个条件(Condition)被满足</p><p>PROPAGATE:值为-3，当线程处在“SHARED”模式时，该字段才会被使用 上</p><p>初始化Node对象时，默认为0</p><p><strong>成员变量:</strong></p><p>waitStatus:该 int 变量表示线程在队列中的状态，其值就是上述提到的 CANCELLED、SIGNAL、CONDITION、PROPAGATE</p><p>prev:该变量类型为 Node 对象，表示该节点的前一个 Node 节点(前驱)</p><p>next:该变量类型为 Node 对象，表示该节点的后一个 Node 节点(后继)</p><p>thread:该变量类型为 Thread 对象，表示该节点的代表的线程</p><p>nextWaiter:该变量类型为 Node 对象，表示等待 condition 条件的 Node 节点</p><hr><p>​    当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点(Node)并将其加入同步队列，同时会阻塞当前线程。</p><p>​    当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。同步队列中的节点(Node)用来保存获取同步状态失败的线程引用、等待状态以及前驱和后继节点。</p><h5 id="head与tail"><a href="#head与tail" class="headerlink" title="head与tail"></a>head与tail</h5><p>​    AQS 还拥有首节点(head)和尾节点(tail)两个引用，一个指向队列头节点，而另一个指向队列尾节点。</p><p>​    PS：因为首节点head是不保存线程信息的节点，仅仅是因为数据结构设计上的需要，在数据结构上，这种做法往往叫做“空头节点链表”。对应的就有“非空头结点链表”</p><h4 id="3）节点在同步队列中的增加与移出"><a href="#3）节点在同步队列中的增加与移出" class="headerlink" title="3）节点在同步队列中的增加与移出"></a>3）节点在同步队列中的增加与移出</h4><h5 id="节点加入到同步队列"><a href="#节点加入到同步队列" class="headerlink" title="节点加入到同步队列"></a>节点加入到同步队列</h5><p>​    当一个线程成功地获取了同步状态(或者锁)，其他线程将无法获取到同步状态，也就是获取同步状态失败，AQS 会将这个线程以及等待状态等信息构造成为一个节点(Node)并将其加入同步队列的尾部。</p><p>​    而这个加入队列的过程必须要保证线程安全，因此同步器提供了一个基于 CAS 的设置尾节点的方法: compareAndSetTail(Node expect,Nodeupdate)，它需要传递当前线程“认为”的尾 节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。</p><h5 id="首节点的变化"><a href="#首节点的变化" class="headerlink" title="首节点的变化"></a>首节点的变化</h5><p>​    首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点。设置首节点是通过获取同步状态成功的线程来完成的，由于只有一个线程能够成功获取到同步状态，因此设置头节点的方法并不需要使用 CAS 来保证，它只需要将首节点设置成为原首节点的后继节点并断开原首节点的next引用即可。</p><h5 id="独占式同步状态的获取与释放"><a href="#独占式同步状态的获取与释放" class="headerlink" title="独占式同步状态的获取与释放"></a>独占式同步状态的获取与释放</h5><h6 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h6><p>​    通过调用同步器的acquire(int arg)方法可以获取同步状态，主要完成了同步状态获取、节点构造、加入同步队列以及在同步队列中自旋等待的相关工作，其主要逻辑是：</p><p><img src="/article/608a8bb5/image-20201207143741068.png" alt="image-20201207143741068"></p><p>​    1、先调用自定义同步器实现的tryAcquire(int arg)方法，该方法需要保证线程安全的获取同步状态。</p><p>​    2、如果同步状态获取失败(tryAcquire 返回 false)，则构造<strong>同步节点</strong>(独占式Node.EXCLUSIVE，同一时刻只能有一个线程成功获取同步状态)并通过addWaiter(Node node)方法将该节点加入到同步队列的尾部。</p><p>​    3、最后调用acquireQueued(Node node,int arg)方法，使得该节点以“死循环” 的方式获取同步状态。如果获取不到则阻塞节点中的线程，而被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现。</p><p>​    addWaiter(Node node)方法中</p><p><img src="/article/608a8bb5/image-20201208130145387.png" alt="image-20201208130145387"></p><p>​    这是将当前线程包装成 Node 后，队列不为空的情况下，先尝试把当前节点加入队列并成为尾节点，如果不成功或者队列为空进入enq(final Node node)方法。</p><p><img src="/article/608a8bb5/image-20201208130319208.png" alt="image-20201208130319208"></p><p>​    在enq(final Node node)方法中，同步器通过“死循环”来保证节点的正确添加，这个死循环中，做了两件事，第一件，如果队列为空，初始化队列，new出一个空节点，并让首节点(head)和尾节点(tail)两个引用都指向这个空节点; 第二件事，把当前节点加入队列。</p><p>​    在“死循环”中只有通过CAS将节点设置成为尾节点之后，当前线程才能从该方法返回，否则，当前线程不断地尝试设置。</p><p>​    节点进入同步队列之后，观察 acquireQueued(Node node,int arg)方法</p><p><img src="/article/608a8bb5/image-20201208131445482.png" alt="image-20201208131445482"></p><p>​    其实就是一个自旋的过程，每个节点(或者说每个线程)都在自省地观察，当条件满足，获取到了同步状态，就可以从这个自旋过程中退出，否则依旧留在这个自旋过程中(并会阻塞节点的线程)。</p><p>​    在acquireQueued(final Node node,int arg)方法中，当前线程在“死循环”中尝试获取同步状态，而只有前驱节点是头节点才能够尝试获取同步状态，这是为什么?原因有两个。</p><p>​    第一，头节点是成功获取到同步状态的节点，而头节点的线程释放了同步状态之后，将会唤醒其后继节点，后继节点的线程被唤醒后需要检查自己的前驱节 点是否是头节点。</p><p>​    第二，维护同步队列的FIFO原则。</p><p>​    当前线程获取到同步状态后，让首节点(head)这个引用指向自己所在节点。 当同步状态获取成功后，当前线程就从acquire方法返回了。如果同步器实现的是锁，那就代表当前线程获得了锁。</p><h6 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h6><p>​    当前线程获取同步状态并执行了相应逻辑之后，就需要释放同步状态，使得后续节点能够继续获取同步状态。通过调用同步器的release(int arg)方法可以释放同步状态，该方法在释放了同步状态之后，会唤醒其后继节点(进而使后继节点重新尝试获取同步状态)。</p><p><img src="/article/608a8bb5/image-20201208133808734.png" alt="image-20201208133808734"></p><p>​    该方法执行时，会唤醒首节点(head)所指向节点的后继节点线程， unparkSuccessor(Node node)方法使用LockSupport来唤醒处于等待状态的线程。</p><p>​    而在 unparkSuccessor 中，</p><p><img src="/article/608a8bb5/image-20201208134329266.png" alt="image-20201208134329266"></p><p>​    这段代码的意思，一般情况下，被唤醒的是 head指向节点的后继节点线程， 如果这个后继节点处于被cancel状态，(我推测开发者的思路这样的:后继节点处于被 cancel 状态，意味着当锁竞争激烈时，队列的第一个节点等了很久(一直被还未加入队列的节点抢走锁)，包括后续的节点 cancel 的几率都比较大，所以) 先从尾开始遍历，找到最前面且没有被cancel的节点。</p><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>​    在获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋;移出队列(或停止自旋)的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用tryRelease(int arg)方法释放同步状态，然后唤醒head指向节点的后继节点。</p><h5 id="共享式同步状态获取与释放"><a href="#共享式同步状态获取与释放" class="headerlink" title="共享式同步状态获取与释放"></a>共享式同步状态获取与释放</h5><p>​    共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时获取到同步状态。以读写为例，如果一个程序在进行读操作，那么这一时刻写操作均被阻塞，而读操作能够同时进行。写操作要求对资源的独占式访问，而读操作可以是共享式访问。</p><p>​    在 acquireShared(int arg)方法中，同步器调用 tryAcquireShared(int arg)方法尝试获取同步状态。tryAcquireShared(int arg)方法返回值为 int 类型，当返回值大于等0时，表示能够获取到同步状态。因此，在共享式获取的自旋过程中，成功获取到同步状态并退出自旋的条件就是 tryAcquireShared(int arg)方法返回值大于等于 0。</p><p>​    可以看到，在 doAcquireShared(int arg)方法的自旋过程中，如果当前节点的前驱为头节点时，尝试获取同步状态，如果返回值大于等于 0，表示该次获取同步状态成功并从自旋过程中退出。</p><p>​    该方法在释放同步状态之后，将会唤醒后续处于等待状态的节点。对于能够支持多个线程同时访问的并发组件(比如 Semaphore)，它和独占式主要区别在 于 tryReleaseShared(int arg)方法必须确保同步状态(或者资源数)线程安全释放， 一般是通过循环和CAS来保证的，因为释放同步状态的操作会同时来自多个线程。</p><h5 id="了解Condition的实现"><a href="#了解Condition的实现" class="headerlink" title="了解Condition的实现"></a>了解Condition的实现</h5><h6 id="Condition的数据结构"><a href="#Condition的数据结构" class="headerlink" title="Condition的数据结构"></a>Condition的数据结构</h6><p>​    等待队列是一个FIFO的队列，在队列中的每个节点都包含了一个线程引用， 该线程就是在Condition对象上等待的线程，如果一个线程调用了Condition.await()方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态。事实上，节点的定义复用了同步器中节点的定义，也就是说，同步队列和等待队列中 节点类型都是同步器的静态内部类。</p><p>​    一个Condition包含一个等待队列，Condition拥有首节点(firstWaiter)和尾节点(lastWaiter)。当前线程调用Condition.await()方法，将会以当前线程构造节点，并将节点从尾部加入等待队列。Condition拥有首尾节点的引用，而新增节点只需要将原有的尾节点nextWaiter指向它，并且更新尾节点即可。上述节点引用更新的过程并没有使用 CAS 保证，原因在于调用await()方法的线程必定是获取了锁的线程，也就是说该过程是由锁来保证线程安全的。</p><p>​    Lock(更确切地说是同步器)拥有一个同步队列和多个等待队列。</p><p><img src="/article/608a8bb5/image-20201209151647024.png" alt="image-20201209151647024"></p><p>​    调用 Condition 的 await()方法(或者以await开头的方法)，会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。当从await()方法返回时， 当前线程一定获取了Condition相关联的锁。</p><p>​    如果从队列(同步队列和等待队列)的角度看await()方法，当调用await()方法时，相当于同步队列的首节点(获取了锁的节点)移动到Condition的等待队列中。</p><p>​    调用该方法的线程成功获取了锁的线程，也就是同步队列中的首节点，该方法会将当前线程构造成节点并加入等待队列中，然后释放同步状态，唤醒同步队列中的后继节点，然后当前线程会进入等待状态。当等待队列中的节点被唤醒，则唤醒节点的线程开始尝试获取同步状态。如果不是通过其他线程调用Condition.signal()方法唤醒，而是对等待线程进行中断，则会抛出 InterruptedException。</p><p>​    如图所示，同步队列的首节点并不会直接加入等待队列，而是通过addConditionWaiter()方法把当前线程构造成一个新的节点并将其加入等待队列 中。</p><p><img src="/article/608a8bb5/image-20201209153217858.png" alt="image-20201209153217858"></p><p>​    调用Condition的signal()方法，将会唤醒在等待队列中等待时间最长的节点 (首节点)，在唤醒节点之前，会将节点移到同步队列中。</p><p><img src="/article/608a8bb5/image-20201209153440498.png" alt="image-20201209153440498"></p><p>​    调用该方法的前置条件是当前线程必须获取了锁，可以看到 signal()方法进行了isHeldExclusively()检查，也就是当前线程必须是获取了锁的线程。接着获取等待队列的首节点，将其移动到同步队列并使用LockSupport唤醒节点中的线程。</p><p>通过调用同步器的 enq(Node node)方法，等待队列中的头节点线程安全地移 动到同步队列。当节点移动到同步队列后，当前线程再使用 LockSupport 唤醒该 节点的线程。</p><p>​    被唤醒后的线程，将从await()方法中的while循环中退出 (isOnSyncQueue(Node node)方法返回 true，节点已经在同步队列中)，进而调用同步器的 acquireQueued()方法加入到获取同步状态的竞争中。</p><p>​    成功获取同步状态(或者说锁)之后，被唤醒的线程将从先前调用的await()方法返回，此时该线程已经成功地获取了锁。</p><p>​    Condition的signalAll()方法，相当于对等待队列中的每个节点均执行一次signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点的线程。</p><h3 id="9、ReentrantLock的实现"><a href="#9、ReentrantLock的实现" class="headerlink" title="9、ReentrantLock的实现"></a>9、ReentrantLock的实现</h3><h4 id="1）锁的可重入"><a href="#1）锁的可重入" class="headerlink" title="1）锁的可重入"></a>1）锁的可重入</h4><p>​    重进入是指任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞， 该特性的实现需要解决以下两个问题。</p><p>​    1.线程再次获取锁。锁需要去识别获取锁的线程是否为当前占据锁的线程， 如果是，则再次成功获取。</p><p>​    2.锁的最终释放。线程重复n次获取了锁，随后在第n次释放该锁后，其他线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减，当计数等于0时表示锁已经成功释放。</p><p>​    nonfairTryAcquire方法增加了再次获取同步状态的处理逻辑:通过判断当前线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请求，则将同步状态值进行增加并返回true，表示获取同步状态成功。同步状态表示锁被一个线程重复获取的次数。</p><p>如果该锁被获取了n次，那么前(n-1)次 tryRelease(int releases)方法必须返回false，而只有同步状态完全释放了，才能返回true。可以看到，该方法将同步状态是否为0作为最终释放的条件，当同步状态为0时，将占有线程设置为null， 并返回true，表示释放成功。</p><h4 id="2）公平和非公平锁"><a href="#2）公平和非公平锁" class="headerlink" title="2）公平和非公平锁"></a>2）公平和非公平锁</h4><p>​    ReentrantLock的构造函数中，默认的无参构造函数将会把Sync对象创建为NonfairSync对象，这是一个“非公平锁”;而另一个构造函数 ReentrantLock(boolean fair)传入参数为true时将会把Sync对象创建为“公平锁” FairSync。</p><p>​    nonfairTryAcquire(int acquires)方法，对于非公平锁，只要CAS设置同步状态成功，则表示当前线程获取了锁，而公平锁则不同。tryAcquire方法，该方法与nonfairTryAcquire(int acquires)比较，唯一不同的位置为判断条件多了 hasQueuedPredecessors()方法，即加入了同步队列中当前节点是否有前驱节点的判断，如果该方法返回true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。</p><h3 id="10、ReentrantReadWriteLock的实现"><a href="#10、ReentrantReadWriteLock的实现" class="headerlink" title="10、ReentrantReadWriteLock的实现"></a>10、ReentrantReadWriteLock的实现</h3><h4 id="1）读写状态的设计"><a href="#1）读写状态的设计" class="headerlink" title="1）读写状态的设计"></a>1）读写状态的设计</h4><p>​    读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。</p><p>​    回想ReentrantLock中自定义同步器的实现，同步状态表示锁被一个线程重复获取的次数，而读写锁的自定义同步器需要在同步状态(一个整型变量)上维护多个读线程和一个写线程的状态，使得该状态的设计成为读写锁实现的关键。</p><p>​    如果在一个整型变量上维护多种状态，就一定需要“<strong>按位切割使用</strong>”这个变量，<strong>读写锁将变量切分成了两个部分，高 16 位表示读，低 16 位表示写</strong>。读写锁是如何迅速确定读和写各自的状态呢?</p><p>​    答案是通过位运算。假设当前同步状态值为 S，写状态等于 S&amp;0x0000FFFF (将高16位全部抹去)，读状态等于 S&gt;&gt;&gt;16(无符号补0右移16位)。当写 状态增加 1 时，等于S+1，当读状态增加1时，等于S+(1&lt;&lt;16)，也就是S+0x00010000。 根据状态的划分能得出一个推论:S不等于0时，当写状态(S&amp;0x0000FFFF)等于0时，则读状态(S&gt;&gt;&gt;16)大于 0，即读锁已被获取。</p><h4 id="2-写锁的获取与释放"><a href="#2-写锁的获取与释放" class="headerlink" title="2) 写锁的获取与释放"></a>2) 写锁的获取与释放</h4><p>​    写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取(读状态不为0)或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。</p><p>​    该方法除了重入条件(当前线程为获取了写锁的线程)之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于读写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。</p><p>​    写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态， 当写状态为0时表示写锁已被释放，从而等待的读写线程能够继续访问读写锁， 同时前次写线程的修改对后续读写线程可见。</p><h4 id="3）-读锁的获取与释放"><a href="#3）-读锁的获取与释放" class="headerlink" title="3） 读锁的获取与释放"></a>3） 读锁的获取与释放</h4><p>​    读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，在没有其他写线程访问(或者写状态为0)时，读锁总会被成功地获取，而所做的也只是(线程安全的)增加读状态。如果当前线程已经获取了读锁，则增加读状态。</p><p>​    如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。读状态是所有线程获取读锁次数的总和，而每个线程各自获取读锁的次数只能选择保存在ThreadLocal中，由线程自身维护。在 tryAcquireShared(int unused)方法中， 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程(线程安全，依靠CAS 保证) 增加读状态，成功获取读锁。读锁的每次释放(线程安全的，可能有多个读线程同时释放读锁)均减少读状态。</p><h4 id="4）锁的升降级"><a href="#4）锁的升降级" class="headerlink" title="4）锁的升降级"></a>4）锁的升降级</h4><p>​    锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。</p><p>​    锁降级是指把持住(当前拥有的)写锁，再获取到读锁，随后释放(先前拥有的)写锁的过程。</p><p>​    RentrantReadWriteLock不支持锁升级(把持读锁、获取写锁，最后释放读锁的过程)。目的是保证数据可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了数据，则其更新对其他获取到读锁的线程是不可见的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程（三）</title>
      <link href="article/d7a792d0.html"/>
      <url>article/d7a792d0.html</url>
      
        <content type="html"><![CDATA[<h2 id="三、原子操作CAS"><a href="#三、原子操作CAS" class="headerlink" title="三、原子操作CAS"></a>三、原子操作CAS</h2><h3 id="1、什么是原子操作？如何实现？"><a href="#1、什么是原子操作？如何实现？" class="headerlink" title="1、什么是原子操作？如何实现？"></a>1、什么是原子操作？如何实现？</h3><p>​    假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时， 要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说是原子的。</p><p>​    实现原子操作可以使用锁，锁机制，满足基本的需求是没有问题的，但是有的时候我们的需求并非这么简单。我们需要更有效，更加灵活的机制。</p><a id="more"></a><p>​     synchronized 关键字是基于阻塞的锁机制，也就是说当一个线程拥有锁的时候， 访问同一资源的其它线程需要等待，直到该线程释放锁，</p><p>​    这里会有些问题:首先，如果被阻塞的线程优先级很高很重要怎么办?其次，如果获得锁的线程一直不释放锁怎么办?(这种情况是非常糟糕的)。还有一种情况，如果有大量的线程来竞争资源，那 CPU 将会花费大量的时间和资源来处理这些竞争，同时，还有可能出现一些例如死锁之类的情况，最后，其实锁机制是一种比较粗糙，粒度比较大的机制，相对于像计数器这样的需求有点儿过于笨重。</p><p>​    实现原子操作还可以使用当前的处理器基本都支持 CAS()的指令，只不过每 个厂家所实现的算法并不一样，每一个 CAS 操作过程都包含三个运算符:一个内存地址 V，一个期望的值A和一个新值B，操作的时候如果这个地址上存放的值等于这个期望的值A，则将地址上的值赋为新值B，否则不做任何操作。</p><p>​    CAS 的基本思路就是，如果这个地址上的值和期望的值相等，则给其赋予新值，否则不做任何事儿，但是要返回原值是多少。循环 CAS 就是在一个循环里不 断的做cas操作，直到成功为止。</p><p>​    CAS 是怎么实现线程的安全呢?语言层面不做处理，我们将其交给硬件——CPU和内存，利用CPU的多处理能力，实现硬件层面的阻塞，再加上volatile变量的特性即可实现基于原子操作的线程安全。</p><h3 id="2、CAS实现原子操作的三大问题"><a href="#2、CAS实现原子操作的三大问题" class="headerlink" title="2、CAS实现原子操作的三大问题"></a>2、CAS实现原子操作的三大问题</h3><h4 id="1）ABA问题"><a href="#1）ABA问题" class="headerlink" title="1）ABA问题"></a>1）ABA问题</h4><p>​    因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用 CAS 进行检查时会发现它的值没有发生变化，但是实际上却变化了。</p><p>​    ABA 问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加 1，那么 A→B→A 就会变成 1A→2B→3A。</p><h4 id="2）循环时间长开销大"><a href="#2）循环时间长开销大" class="headerlink" title="2）循环时间长开销大"></a>2）循环时间长开销大</h4><p>​    自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p><h4 id="3）只能保证一个共享变量的原子操作"><a href="#3）只能保证一个共享变量的原子操作" class="headerlink" title="3）只能保证一个共享变量的原子操作"></a>3）只能保证一个共享变量的原子操作</h4><p>​    当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操 作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候 就可以用锁。</p><p>​    还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量 i=2，j=a，合并一下 ij=2a，然后用CAS来操作 ij。从Java 1.5 开始，JDK 提供了AtomicReference类来保证引用对象之间的原子性，就可以把 多个变量放在一个对象里来进行CAS操作。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程（二）</title>
      <link href="article/9ab93182.html"/>
      <url>article/9ab93182.html</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1380874318&auto=0&height=66"></iframe><h2 id="二、线程的并发工具类"><a href="#二、线程的并发工具类" class="headerlink" title="二、线程的并发工具类"></a>二、线程的并发工具类</h2><h3 id="1、Fork-Join"><a href="#1、Fork-Join" class="headerlink" title="1、Fork-Join"></a>1、Fork-Join</h3><p>​    遵循Fork-Join（分治）思想可以让我们写出非常良好的多线程并发程序。在十大计算机经典算法中，使用了分治思想的有快速排序，归并排序，二分查找，同时大数据中M/R也使用了分治思想。</p><p>​    分治法的设计思想是:将一个难以直接解决的大问题，分割成一些规模较小 的相同问题，以便各个击破，分而治之。</p><p>​    分治策略是:对于一个规模为 n 的问题，若该问题可以容易地解决(比如说规模 n 较小)则直接解决，否则将其分解为 k个规模较小的子问题，这些子问题互相独立且与原问题形式相同**(子问题相互之间有联系就会变为动态规范算法)**，递归地解这些子问题，然后将各子问题的解合并得到原问题的解，这种算法设计策略叫做分治法。</p><a id="more"></a><h4 id="1）归并排序"><a href="#1）归并排序" class="headerlink" title="1）归并排序"></a>1）归并排序</h4><p>​    归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列;即先使 每个子序列有序，再使子序列段间有序。</p><p>​    若将两个有序表合并成一个有序表，称为 2-路归并，与之对应的还有多路归 并。</p><p>​    对于给定的一组数据，利用递归与分治技术将数据序列划分成为越来越小的 半子表，在对半子表排序后，再用递归方法将排好序的半子表合并成为越来越大 的有序序列。</p><p>​    为了提升性能，有时我们在半子表的个数小于某个数的情况下，对半子表的排序采用其他排序算法，比如插入排序。</p><h4 id="2）FJ原理"><a href="#2）FJ原理" class="headerlink" title="2）FJ原理"></a>2）FJ原理</h4><p><img src="/article/9ab93182/image-20201124221023112.png" alt="image-20201124221023112"></p><p><img src="/article/9ab93182/image-20201124221035086.png" alt="image-20201124221035086"></p><p>​    即当前线程的Task已经全被执行完毕，则自动取到其他线程的Task池中取出Task继续执行。</p><p>​    ForkJoinPool中维护着多个线程(一般为CPU核数)在不断地执行Task，每个线程除了执行自己职务内的Task之外，还会根据自己工作线程的闲置情况去 获取其他繁忙的工作线程的Task，如此一来就能能够减少线程阻塞或是闲置的时间，提高CPU利用率。</p><h4 id="3）FJ标准范式"><a href="#3）FJ标准范式" class="headerlink" title="3）FJ标准范式"></a>3）FJ标准范式</h4><p>​    我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork和join的操作机制，通常我们不直接继承ForkjoinTask类，只需要直接继承其子类。</p><pre><code>1.RecursiveAction，用于没有返回结果的任务2.RecursiveTask，用于有返回值的任务</code></pre><p>​    task 要通过ForkJoinPool来执行，使用submit或invoke提交，两者的区别是:invoke是同步执行，调用之后需要等待任务完成，才能执行后面的代码,submit是异步执行。</p><p>​    join()和get方法当任务完成的时候返回计算结果。</p><p><img src="/article/9ab93182/image-20201124221434571.png" alt="image-20201124221434571"></p><h3 id="2、CountDownLatch"><a href="#2、CountDownLatch" class="headerlink" title="2、CountDownLatch"></a>2、CountDownLatch</h3><p>​    通称闭锁，能够使得一个线程等待其他线程完成各自的工作后再执行。</p><p>​    CountDownLatch是通过计数器来实现的，初始值为任务的数量。每当完成一个任务后，计数器值减一。当计数器值达到0时，表示所有的线程已经完成了任务，然后在闭锁上等待await()方法的线程将恢复任务的执行。</p><p><img src="/article/9ab93182/image-20201124222415883.png" alt="image-20201124222415883"></p><p>​    可以有多个线程调用await()，计数器初始化数量也不必必须等同于需要等待执行的线程数，而是根据实际场景设置。</p><h3 id="3、CyclicBarrier"><a href="#3、CyclicBarrier" class="headerlink" title="3、CyclicBarrier"></a>3、CyclicBarrier</h3><p>​    CyclicBarrier的字面意思是可循环使用(Cyclic)的屏障(Barrier)。它要做的事情是，让一组线程到达一个屏障(也可以叫同步点)时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。</p><p>​    CyclicBarrier还提供一个更高级的构造函数CyclicBarrier(int parties，Runnable barrierAction)，用于在线程到达屏障时，优先执行 barrierAction，可以用于多线程计算数据，最后合并计算结果的场景。</p><h3 id="4、CountDownLatch和CyclicBarrier辨析"><a href="#4、CountDownLatch和CyclicBarrier辨析" class="headerlink" title="4、CountDownLatch和CyclicBarrier辨析"></a>4、CountDownLatch和CyclicBarrier辨析</h3><pre><code>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以反复使用。CountDownLatch.await一般阻塞工作线程，所有的进行预备工作的线程执行countDown，而 CyclicBarrier通过工作线程调用await从而自行阻塞，直到所有工作线程达到指定屏障，再大家一起往下走。在控制多个线程同时运行上，CountDownLatch 可以不限线程数量，而 CyclicBarrier是固定线程数。同时，CyclicBarrier还可以提供一个barrierAction，合并多线程计算结果。</code></pre><h3 id="5、Semaphore"><a href="#5、Semaphore" class="headerlink" title="5、Semaphore"></a>5、Semaphore</h3><p>​    Semaphore(信号量)是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</p><p>​    Semaphore的构造方法 Semaphore(int permits)接受一个整型的数字， 表示可用的许可证数量。Semaphore的用法也很简单，首先线程使用Semaphore的acquire()方法获取一个许可证，使用完之后调用 release()方法归还许可证。还可以用tryAcquire()方法尝试获取许可证。</p><h3 id="6、Exchanger"><a href="#6、Exchanger" class="headerlink" title="6、Exchanger"></a>6、Exchanger</h3><p>​    Exchanger(交换者)是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。</p><p>​    它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过 exchange()方法交换数据，如果第一个线程先执行 exchange()方法，它会一直等待第二个线程也执行 exchange()方法，当两个线程都 到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</p><h3 id="7、Callable、Future和FutureTask"><a href="#7、Callable、Future和FutureTask" class="headerlink" title="7、Callable、Future和FutureTask"></a>7、Callable、Future和FutureTask</h3><p>​    Runnable是一个接口，在它里面只声明了一个 run()方法，由于run()方法返回值为void类型，所以在执行完任务之后无法返回任何结果。</p><p>​    Callable位于java.util.concurrent包下，它也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做call()，这是一个泛型接口，call()函数返回的类型就是传递进来的V类型。</p><p>​    Future就是对于具体的Runnable或者Callable 任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻 塞直到任务返回结果。</p><p><img src="/article/9ab93182/image-20201127164619275.png" alt="image-20201127164619275"></p><p>​    因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了FutureTask。</p><p>​    FutureTask 类实现了RunnableFuture接口，RunnableFuture继承了Runnable接口和Future接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</p><p>​    因此我们通过一个线程运行Callable，但是Thread不支持构造方法中传递Callable的实例，所以我们需要通过FutureTask把一个Callable包装成 Runnable， 然后再通过这个FutureTask拿到Callable运行后的返回值。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程（一）</title>
      <link href="article/aaafdd5a.html"/>
      <url>article/aaafdd5a.html</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=454231736&auto=0&height=66"></iframe><h2 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a>一、基础概念</h2><h3 id="1、什么是进程与线程"><a href="#1、什么是进程与线程" class="headerlink" title="1、什么是进程与线程"></a>1、什么是进程与线程</h3><p>进程：操作系统进行资源分配的最小单位</p><p>线程：CPU调度的最小单位，无法独立进程而存在</p><h3 id="2、CPU核心数和线程数的关系"><a href="#2、CPU核心数和线程数的关系" class="headerlink" title="2、CPU核心数和线程数的关系"></a>2、CPU核心数和线程数的关系</h3><p>一对一关系，使用Intel超线程技术可以使其变成一比二关系。</p><h3 id="3、CPU时间片轮转机制"><a href="#3、CPU时间片轮转机制" class="headerlink" title="3、CPU时间片轮转机制"></a>3、CPU时间片轮转机制</h3><p>RR调度：把CPU时间切片，分配给不同的进程进行运行。</p><p>缺点：上下文切换需要花费20000CPU时间周期</p><a id="more"></a><h3 id="4、并行与并发"><a href="#4、并行与并发" class="headerlink" title="4、并行与并发"></a>4、并行与并发</h3><p>并行：应用可以同时运行的任务数</p><p>并发：一定时间内可以交替执行的任务数（与时间相关）</p><p>并发的优点：</p><ul><li>充分利用CPU资源</li><li>加快相应用户的时间</li><li>可以使代码模块化，异步化，简单化。</li></ul><h3 id="5、线程的数量限制"><a href="#5、线程的数量限制" class="headerlink" title="5、线程的数量限制"></a>5、线程的数量限制</h3><p>在操作系统中，一个进程所能创建的最大线程数如下：</p><p>Linux：1000    Windows：2000</p><h3 id="6、JAVA程序天生就是多线程的，那么有几种新启线程的方式？"><a href="#6、JAVA程序天生就是多线程的，那么有几种新启线程的方式？" class="headerlink" title="6、JAVA程序天生就是多线程的，那么有几种新启线程的方式？"></a>6、JAVA程序天生就是多线程的，那么有几种新启线程的方式？</h3><p>结论：一共有两种。</p><ul><li>类Thread</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private static class userThread extends Thread&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            super.run();</span><br><span class="line">            &#x2F;&#x2F;to do my work</span><br><span class="line">            System.out.println(&quot;I am extends Thread&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>接口Runnable</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static class userRunnable  implements Runnable&#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void run() &#123;</span><br><span class="line">         &#x2F;&#x2F;to do my work</span><br><span class="line">         System.out.println(&quot;I am implements Runnable&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>启动方式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        userThread userThread &#x3D; new userThread();</span><br><span class="line">        userThread.start();</span><br><span class="line">        userRunnable userRunnable &#x3D; new userRunnable();</span><br><span class="line">        Thread thread &#x3D; new Thread(userRunnable);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>Thread与Runnable的区别</li></ul><p>Thread是java中对线程的抽象。</p><p>Runnable是对任务（业务逻辑）的抽象。</p><h3 id="7、如何让java线程安全的停止？"><a href="#7、如何让java线程安全的停止？" class="headerlink" title="7、如何让java线程安全的停止？"></a>7、如何让java线程安全的停止？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*jdk线程是协作式的，并非抢占式  </span><br><span class="line"></span><br><span class="line">stop()&#x2F;&#x2F;停止：非常野蛮，可能导致线程中资源不能正确释放</span><br><span class="line">interrupt()&#x2F;&#x2F;中断：对线程发起中断，给线程打了中断标示位，线程可以不理会，正确姿势</span><br><span class="line">Thread.interrupted()&#x2F;&#x2F;静态 ，调用中断后会将中断标识位由true改为false</span><br><span class="line">isinterrupted()&#x2F;&#x2F;返回中断状态</span><br></pre></td></tr></table></figure><h3 id="8、java线程认知"><a href="#8、java线程认知" class="headerlink" title="8、java线程认知"></a>8、java线程认知</h3><p><img src="/article/aaafdd5a/image-20201117225548901.png" alt="image-20201117225548901"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;new Thread（）的时候只是new出了一个线程抽象类的实例，并没有和线程挂钩</span><br><span class="line">&#x2F;&#x2F;当Thread.start()的时候，才真正和线程挂钩</span><br><span class="line"></span><br><span class="line">只允许调用一次如果运行两次，会直接抛出异常</span><br></pre></td></tr></table></figure><ul><li>线程常用方法和线程的状态</li></ul><p><strong>深入理解run()，strat()与yield()</strong></p><p>​        run()方法可以被任意线程调用，start()方法是该线程主动调用。</p><p>​        yield()：使当前线程让出 CPU 占有权，但让出的时间是不可设定的。也 不会释放锁资源。</p><ul><li><p>join()方法 </p><p>​    使用join可以使得线程中执行顺序变成串行，保证不同线程之间的顺序执行</p></li><li><p>线程的优先级</p><p>​    Thread.setPriority(int) //1~10,默认5</p></li><li><p>守护线程</p><p>​    在程序中做一些调度的工作，通过Thread.setDeamon(true)设置。</p></li></ul><h3 id="9、线程间共享"><a href="#9、线程间共享" class="headerlink" title="9、线程间共享"></a>9、线程间共享</h3><h4 id="synchronized内置锁"><a href="#synchronized内置锁" class="headerlink" title="synchronized内置锁"></a><strong>synchronized内置锁</strong></h4><p>​    由于Java支持多个线程同事访问一个对象或对象的成员变量，关键字synchronized可以修饰方法或者以同步块的形式来使用。</p><p>​    它主要确保多个线程在同一时刻，只能有一个线程处于方法或者同步块中，保证了线程对变量访问的可见性和排他性，又称为内置锁机制。</p><p>​    本质是<strong>锁住某个对象</strong>，当修饰在类上时，实际上锁住的是该类在虚拟机中仅有的class对象。所以类锁和对象锁可以并行。</p><h4 id="错误的加锁和原因分析"><a href="#错误的加锁和原因分析" class="headerlink" title="错误的加锁和原因分析"></a>错误的加锁和原因分析</h4><p>​    因为通过synchronized锁住的是对象，加锁过程中对象不能发生变化。</p><h4 id="volatile——最轻量的同步机制"><a href="#volatile——最轻量的同步机制" class="headerlink" title="volatile——最轻量的同步机制"></a>volatile——最轻量的同步机制</h4><p>​    只能保证数据的可见性（旧数据修改后，其他线程能够立即访问到），但不能保证数据的原子性，所以不能取代synchronized。</p><p>​    比较适合<strong>一写多读</strong>的线程工作场景。</p><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p>​    为每个线程提供变量的副本，使得每一个线程都在某一个时间访问到的并非同一个对象，实现了<strong>线程的隔离</strong>。</p><p>​    <em>Spring中什么地方用到了ThreadLocal？（事物）</em></p><h5 id="可能引发内存泄漏的分析"><a href="#可能引发内存泄漏的分析" class="headerlink" title="可能引发内存泄漏的分析"></a>可能引发内存泄漏的分析</h5><h6 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h6><p>Object o = new Object();</p><p>​    执行的方法会打包成一个栈帧在栈上运行，new一个对象时在堆中生成实例 。</p><p>​    栈上的o指向堆中的Object对象，这就是引用。</p><h6 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h6><p>SortRefence。在即将发生内存溢出的时候，先做一次垃圾回收。如果空间还是不够，就会将标记了软引用的对象进行回收。</p><h6 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h6><p>只要发生GC，被弱引用所指的堆内对象实例就会被回收。</p><h6 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h6><p>基本无用，发生GC时候仅通知一下</p><hr><p>​    每个Thread维护了一个ThreadLocalMap，ThreadLocal本身不存储值，仅作为一个key来让线程从ThreadLocalMap中获取value，该map是使用ThreadLocal的弱引用作为key。</p><p>​    因此，引用链如下所示：</p><p><img src="/article/aaafdd5a/image-20201123192854144.png" alt="image-20201123192854144"></p><p>​    当把 ThreadLocal 变量置为 null 以后，没有任何强引用指向 ThreadLocal 实例，所以 ThreadLocal 将会被 gc 回收。这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry，就没有办法访问这些 key 为 null 的 Entry 的 value，如果当前 线程再迟迟不结束的话，这些 key 为 null 的 Entry 的 value 就会一直存在一条强 引用链:Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value，而这块 value 永 远不会被访问到了，所以存在着内存泄露。</p><p>​    只有当前 Thread 结束以后，Current Thread 就不会存在栈中，强引用断开， Current Thread、Map value 将全部被 GC 回收。最好的做法是不在需要使用 ThreadLocal 变量后，都调用它的 remove()方法，清除数据。</p><p>​    ThreadLocal 内存泄漏的根源是:由于 ThreadLocalMap 的生命周期跟 Thread 一样长，如果没有手动删除对应 key 就会导致内存泄漏，而不是因为弱引用。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>1、JVM 利用设置 ThreadLocalMap 的 Key为弱引用，来避免内存泄露。</p><p>2、JVM 利用调用 remove、get、set 方法的时候，回收弱引用</p><p>3、当 ThreadLocal 存储很多 Key 为 null 的 Entry 的时候，而不再去调用 remove、get、set 方法，那么将导致内存泄漏。</p><p>4、使用线程池**+** ThreadLocal 时要小心，因为这种情况下，线程是一直在不断的重复运行的，从而也就造成了 value 可能造成累积的情况。</p><h3 id="10、线程间协作"><a href="#10、线程间协作" class="headerlink" title="10、线程间协作"></a>10、线程间协作</h3><p>​    线程之间相互配合，完成某项工作，比如:一个线程修改了一个对象的值， 而另一个线程感知到了变化，然后进行相应的操作，整个过程开始于一个线程， 而最终执行又是另一个线程。前者是生产者，后者就是消费者，这种模式隔离了 “做什么”(what)和“怎么做”(How)，简单的办法是让消费者线程不断地 循环检查变量是否符合预期在 while 循环中设置不满足的条件，如果条件满足则 退出 while 循环，从而完成消费者的工作。却存在如下问题:</p><p> 难以确保及时性。</p><p>2、难以降低开销。如果降低睡眠的时间，比如休眠1毫秒，这样消费者能更加迅速地发现条件变化，但是却可能消耗更多的处理器资源，造成了无端的浪费。</p><h4 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h4><p>标准范式遵循如下原则：</p><hr><p>等待方原则</p><p>1、获取对象的锁</p><p>2、如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。</p><p>3、条件满足则执行对应的逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">synchronized(对象)&#123;</span><br><span class="line">while(条件不满足)&#123;</span><br><span class="line">对象.wait();</span><br><span class="line">&#125;</span><br><span class="line">对应的处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通知方原则</p><p>1、获取对象的锁</p><p>2、改变条件</p><p>3、通知所有等待在对象上的线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized(对象)&#123;</span><br><span class="line">改变条件</span><br><span class="line">对象.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>​    <strong>在调用 wait()、notify()系列方法之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步块中调用 wait()方法、notify()系列方法</strong>。</p><p>​    进入 wait()方法后，<strong>当前线程释放锁</strong>，在从 wait()返回前，线程与其他线程竞争重新获得锁，执行 notify()系列方法的线程退出调用了 notifyAll 的 synchronized 代码块的时候后，他们就会去竞争。如果其中一个线程获得了该对象锁，它就会继续往下执行，在它退出 synchronized 代码块，释放锁后，其他的已经被唤醒的线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。</p><p>​    尽可能用 notifyall()，谨慎使用 notify()，因为 notify()只会唤醒一个线程，我们无法确保被唤醒的这个线程一定就是我们需要唤醒的线程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码分析</title>
      <link href="article/9439442c.html"/>
      <url>article/9439442c.html</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=21253900&auto=0&height=66"></iframe><h1 id="Spring源码分析"><a href="#Spring源码分析" class="headerlink" title="Spring源码分析"></a>Spring源码分析</h1><h2 id="一、源码下载与编译"><a href="#一、源码下载与编译" class="headerlink" title="一、源码下载与编译"></a>一、源码下载与编译</h2><p>​    环境说明：</p><ul><li>Spring-framerwork5.3.2</li><li>Gradle6.7</li><li>IDEA2020.2.3</li></ul><h3 id="Mac下Gradle的安装与配置"><a href="#Mac下Gradle的安装与配置" class="headerlink" title="Mac下Gradle的安装与配置"></a>Mac下Gradle的安装与配置</h3><p>​    进入Gradle官网，选择安装版本，Binary-only下载压缩包。</p><p>​    将在指定目录下解压，然后配置环境变量。</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 进入用户目录下的配置文件</span><br><span class="line">vim ~&#x2F;.bash_profile</span><br><span class="line"># 修改.bash_profile文件, 在文件的最后加上如下配置: </span><br><span class="line"># export GRADLE&#x3D;&#x2F;指定路径&#x2F;gradle-6.7</span><br><span class="line"># export PATH&#x3D;$PATH:$GRADLE&#x2F;bin</span><br><span class="line"># 修改后, 按[Esc], 命令&quot;:wq&quot;保存退出, 并在终端使用如下命令使配置生效:</span><br><span class="line">source ~&#x2F;.bash_profile</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><a id="more"></a><h4 id="bash-profile找不到"><a href="#bash-profile找不到" class="headerlink" title=".bash_profile找不到"></a>.bash_profile找不到</h4><p>​    直接vim ~/.bash_profile进入的是空文件，而且.bash_profile是隐藏文件，没有开启显示的情况下访达不能直接搜索到。</p><p>​    查阅资料都是说如果找不到就自己新建一个，但环境变量如果消失的话，应该是除了cd以外的命令均无法使用。并且我之前配置的java环境变量使用-version命令能够正常显示，说明.bash_profile文件应该还存在并且生效。</p><p>​    最后发现，由于我此时使用的是提权的root用户，～进入的是/var/root路径。新打开一个终端，使用普通用户访问～路径，进入的是/Users/用户名目录。此时能够正常访问到之前设置的.bash_profile文件。</p><h2 id="Spring源码下载"><a href="#Spring源码下载" class="headerlink" title="Spring源码下载"></a>Spring源码下载</h2><p>​    1.在指定位置新建文件夹，终端进入后输入以下语句以进行下载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;gitee.com&#x2F;mirrors&#x2F;Spring-Framework.git</span><br></pre></td></tr></table></figure><p>2.设置阿里云镜像提速</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在下载好的Spring源码文件夹里的build.gradle 加上</span><br><span class="line">allprojects &#123;</span><br><span class="line">repositories &#123;</span><br><span class="line">maven&#123; url &#39;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;&#39;&#125;</span><br><span class="line">maven &#123; url &#39;https:&#x2F;&#x2F;maven.aliyun.com&#x2F;repository&#x2F;gradle-plugin&#39; &#125;</span><br><span class="line">maven &#123; url &#39;https:&#x2F;&#x2F;maven.aliyun.com&#x2F;repository&#x2F;google&#39; &#125;</span><br><span class="line">maven &#123; url &#39;https:&#x2F;&#x2F;maven.aliyun.com&#x2F;repository&#x2F;jcenter&#39;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/article/9439442c/image-20201116002343235.png" alt="image-20201116002343235"></p><p>3.cd进入下载的Spring源码路径执行gradle命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gradle objenesisRepackJar</span><br><span class="line">gradle cglibRepackJar</span><br><span class="line">gradlew :spring-oxm:compileTestJava</span><br></pre></td></tr></table></figure><hr><h3 id="可能出现的问题："><a href="#可能出现的问题：" class="headerlink" title="可能出现的问题："></a>可能出现的问题：</h3><p>1、Could not determine the dependencies of task ‘:spring-oxm:compileTestKotlin’.</p><p><img src="/article/9439442c/image-20201115143844838.png" alt="image-20201115143844838"></p><p>解决方法：</p><p>​    由于我使用的是最新版本Gradle，所以需要下载最新版本Spring源码进行编译，或者对Gradle进行降级。</p><hr><p>2、Could not determine the dependencies of task ‘:spring-core:objenesisRepackJar’.</p><p><img src="/article/9439442c/image-20201115144348247.png" alt="image-20201115144348247"></p><p>解决方法：</p><p>​    运行gradle objenesisRepackJar，然后重新执行gradlew :spring-oxm:compileTestJava</p><hr><p>3、Could not GET ‘xxx’.Read timed out</p><p><img src="/article/9439442c/image-20201115144532777.png" alt="image-20201115144532777"></p><p>解决方法：</p><p>​    网络问题导致超时，重新执行gradlew :spring-oxm:compileTestJava直到编译成功</p><p>4、连续编译失败（网络问题）</p><p><img src="/article/9439442c/image-20201115160644761.png" alt="image-20201115160644761"></p><p>解决方法：</p><p>​    分别单独执行gradlew :spring-oxm:compileJava，gradlew :spring-core:compileTestFixturesKotlin以及gradlew :spring-aop:compileJava。</p><p>​    执行完成后重新执行gradlew :spring-oxm:compileTestJava直到编译成功</p><hr><p>最终结果</p><p><img src="/article/9439442c/image-20201115172915609.png" alt="image-20201115172915609"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    此次源码下载与编译花费了我大量时间，从早上十点到下午五点半才最终编译成功。</p><p>​    最大的问题就是第一个，由于Gradle版本过于新，导致较旧的spring源码无法正常编译。网上直接搜索所报错误，基本上都是安卓相关，没有任何参考价值。</p><p>​    其次就是编译过程中jar包下载，让我感觉回到了15年前拨号上网的时候。不仅下载巨慢，而且期间不断报错，一遍遍重新编译的过程中耗费了我非常多的精力。</p><p>​    尤其是在最后98%阶段的byte-buddy-1.10.15.jar包，只有3.3m的大小，但从下载到最终结束一共花费了两个多小时。因为每次下载到最后总会报出ssl管道异常关闭的错误，不得不一遍遍重复。</p><p><img src="/article/9439442c/image-20201115174014323.png" alt="image-20201115174014323"></p><hr><p>​    现在是晚上12点，idea终于开始正常编译了，以下是经验教训。</p><ul><li><p>​    最新版本的Gradle+最新版本的Spring可以完成编译，但是idea无法正常导入。一开始我以为是编译慢的原因，结果编译了两个小时还没动静，就重新开始查阅资料，一遍一遍的重装。最后发现，还得把<strong>idea的版本升级到最新</strong>，才能正常导入。</p><p>​    此处借鉴<a href="https://blog.csdn.net/qq_38425803/article/details/109670018">夯实Spring（五） | 搭建Spring源码环境</a></p></li><li><p>  Gradle编译前，可以通过设置阿里云镜像提速，不然得像我一样下载几个小时</p></li></ul><p>​    至于有没有效果，因为我已经下载过了，所以不清楚提速有多快。</p><ul><li>通过设置本地Gradle，避免idea从网页重复下载</li></ul><p><img src="/article/9439442c/image-20201116002545689.png" alt="image-20201116002545689"></p><hr><h3 id="截图留念"><a href="#截图留念" class="headerlink" title="截图留念"></a>截图留念<img src="/article/9439442c/image-20201116003207637.png" alt="image-20201116003207637"></h3>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>与其不断的规划，我决定先行动起来</title>
      <link href="article/a4b9cf5f.html"/>
      <url>article/a4b9cf5f.html</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=22842399&auto=0&height=66"></iframe><p><em>这是一篇关于我的故事</em></p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>​    我决定开设个人博客了。工作两年多以来，从我正式入职开始，公司就没有把我当作新人使用。无止境的产品更新需求，开发过程中遇到的各类bug，客户的对接…由于工作任务繁重，初始薪资太低，生存下去成为了我在北京最首要的任务。</p><a id="more"></a><h2 id="第一年"><a href="#第一年" class="headerlink" title="第一年"></a>第一年</h2><p>​    入职第一年，我所有的时间全部花在解决公司项目的问题上面。</p><p>​    经历过连续一个半月的凌晨三点到家，七点爬起来去上班。调试解决过无数奇异bug，总结编写了许多文档。对接了许多客户，尽心尽力为其解决问题。</p><p>​    凭借个人努力，这一年期间我摸透了项目各种需求流程，独自开发了多项功能业务模块。虽然我在项目开发中越来越得心应手，但由于我所在的项目组所用技术较老，个人提升实在有限。</p><p>​    这一年间最大的任务和收获，是由我独自负责对接深信服接口。由我开发的接口项目，无论是对接还是验收都是最快和运行最稳定的。</p><h2 id="第二年"><a href="#第二年" class="headerlink" title="第二年"></a>第二年</h2><p>​    时间进入到第二年，收入接近翻了一倍，虽然起薪很低，但至少不用一餐只敢点十多块的外卖了。    第二年开始，对于交给我的需求与任务，我已经能非常轻松的完成开发。由于疫情原因，团队组织架构调整。我开始担任小组长，初期领导了一个十人小组。我手下的组员，由于大部分都是新人，除了开发任务外，我还注重其能力提升培养。</p><p>​    年初的工作任务实在是非常繁忙，连续三个月不间断上班，每天15个小时以上的工作时长，我一共只休息了两天。这期间由于护网要求，以及深信服被爆出0day漏洞的原因，我们项目需要进行安全性的整体提升。</p><p>​    由于第一年我有项目漏洞处理经验，三个月时间，我组人员在我带领下对项目进行了整体改造。最终达到了安全基线的所有要求，解决了一系列web漏洞相关问题。由我负责的漏洞修补工作，使得我们产品在护网期间没有报出任何问题，这三个月时间，对于web安全相关知识收获颇多。</p><p>​    如果说第一年实在是为工作任务所迫，没有时间进行其他方面的提升。那么第二年后半期，在漏洞处理解决后，向管理岗转化的时候，我开始有了大把时间，却变得稍有懈怠，进入了一个舒适区陷阱。</p><h3 id="惊醒"><a href="#惊醒" class="headerlink" title="惊醒"></a>惊醒</h3><p>​    日子一天天过去，曾经我有计划工作积攒经验三年后跳槽，我向往着阿里，字节，腾讯，微软等大厂。之前也对其招聘标准有一个模糊的概念，那就是我现在的技术不足以去面试，但我所掌握的东西距离所需技术究竟缺少多少呢？我并没有很清楚的认识到。</p><p>​    打开招聘网站，社招除了工作经验的要求外，各种所需技术就是轻飘飘的一句话，但这一句话的背后，所需要掌握的知识绝对是海量的。</p><p>​    某一天看番后闲着没事干，我打开了b站搜索java面试。其中尚硅谷周阳老师的面试指导第一章节就把我骂得头破血流，我这时我才明白，我之前两年的工作经验，对于当前的公司，我是重要的人才。因为我熟练掌握项目需求，开发所需技能。但实际上，我只是一个普通的CRUD工程师而已。为数不多的有价值技能，是我对待工作的认真态度，web漏洞的修复经验，工作期间见到的各类bug而已。</p><h3 id="决意"><a href="#决意" class="headerlink" title="决意"></a>决意</h3><p>​    我决定制定计划，从基础开始覆盖整个java高级工程师所需技术栈，用五至十个月时间，完整掌握所有相关内容。</p><p>​    由于目前有新项目在身，我首先要以公司工作内容为主，每天所有业余时间拿来学习。如果工作内容占用时间不是很多，快速掌握的情况下，也许可以冲击春招（5个月），如果工作内容繁重，那就只能以工作内容为主，冲击明年的秋招。</p><p>​    学习过程中所有资料，将会整理并发布到该个人博客。</p><p>​    </p>]]></content>
      
      
      
        <tags>
            
            <tag> 初めて </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
